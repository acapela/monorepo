schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type GetDownloadUrlResponse {
  downloadUrl: String!
}

type GetUploadUrlResponse {
  uploadUrl: String!
  uuid: ID!
}

input InviteAcceptCommand {
  code: String!
}

type InviteAcceptResponse {
  invite: room_invites
  invite_id: ID!
  room: room
  room_id: ID!
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

type UpgradeUserResponse {
  user: user
  user_id: ID!
}

"""
Account represents 3rd party login methods used by given user.


columns and relationships of "account"

"""
type account {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz!
  id: uuid!
  provider_account_id: String!
  provider_id: String!
  provider_type: String!
  refresh_token: String
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "account"
"""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"""
aggregate fields of "account"
"""
type account_aggregate_fields {
  count(columns: [account_select_column!], distinct: Boolean): Int
  max: account_max_fields
  min: account_min_fields
}

"""
order by aggregate values of table "account"
"""
input account_aggregate_order_by {
  count: order_by
  max: account_max_order_by
  min: account_min_order_by
}

"""
input type for inserting array relation for remote table "account"
"""
input account_arr_rel_insert_input {
  data: [account_insert_input!]!
  on_conflict: account_on_conflict
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input account_bool_exp {
  _and: [account_bool_exp]
  _not: account_bool_exp
  _or: [account_bool_exp]
  access_token: String_comparison_exp
  access_token_expires: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider_account_id: String_comparison_exp
  provider_id: String_comparison_exp
  provider_type: String_comparison_exp
  refresh_token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "account"
"""
enum account_constraint {
  """unique or primary key constraint"""
  account_pkey
}

"""
input type for inserting data into table "account"
"""
input account_insert_input {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type account_max_fields {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "account"
"""
input account_max_order_by {
  access_token: order_by
  access_token_expires: order_by
  created_at: order_by
  id: order_by
  provider_account_id: order_by
  provider_id: order_by
  provider_type: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type account_min_fields {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "account"
"""
input account_min_order_by {
  access_token: order_by
  access_token_expires: order_by
  created_at: order_by
  id: order_by
  provider_account_id: order_by
  provider_id: order_by
  provider_type: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "account"
"""
type account_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [account!]!
}

"""
input type for inserting object relation for remote table "account"
"""
input account_obj_rel_insert_input {
  data: account_insert_input!
  on_conflict: account_on_conflict
}

"""
on conflict condition type for table "account"
"""
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]!
  where: account_bool_exp
}

"""
ordering options when selecting data from "account"
"""
input account_order_by {
  access_token: order_by
  access_token_expires: order_by
  created_at: order_by
  id: order_by
  provider_account_id: order_by
  provider_id: order_by
  provider_type: order_by
  refresh_token: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "account"
"""
input account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "account"
"""
enum account_select_column {
  """column name"""
  access_token

  """column name"""
  access_token_expires

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  provider_account_id

  """column name"""
  provider_id

  """column name"""
  provider_type

  """column name"""
  refresh_token

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "account"
"""
input account_set_input {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "account"
"""
enum account_update_column {
  """column name"""
  access_token

  """column name"""
  access_token_expires

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  provider_account_id

  """column name"""
  provider_id

  """column name"""
  provider_type

  """column name"""
  refresh_token

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "attachment"
"""
type attachment {
  created_at: timestamptz!
  id: uuid!
  mime_type: String!
  original_name: String!
}

"""
aggregated selection of "attachment"
"""
type attachment_aggregate {
  aggregate: attachment_aggregate_fields
  nodes: [attachment!]!
}

"""
aggregate fields of "attachment"
"""
type attachment_aggregate_fields {
  count(columns: [attachment_select_column!], distinct: Boolean): Int
  max: attachment_max_fields
  min: attachment_min_fields
}

"""
order by aggregate values of table "attachment"
"""
input attachment_aggregate_order_by {
  count: order_by
  max: attachment_max_order_by
  min: attachment_min_order_by
}

"""
input type for inserting array relation for remote table "attachment"
"""
input attachment_arr_rel_insert_input {
  data: [attachment_insert_input!]!
  on_conflict: attachment_on_conflict
}

"""
Boolean expression to filter rows from the table "attachment". All fields are combined with a logical 'AND'.
"""
input attachment_bool_exp {
  _and: [attachment_bool_exp]
  _not: attachment_bool_exp
  _or: [attachment_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  mime_type: String_comparison_exp
  original_name: String_comparison_exp
}

"""
unique or primary key constraints on table "attachment"
"""
enum attachment_constraint {
  """unique or primary key constraint"""
  attachment_id_key

  """unique or primary key constraint"""
  attachment_pkey
}

"""
input type for inserting data into table "attachment"
"""
input attachment_insert_input {
  created_at: timestamptz
  id: uuid
  mime_type: String
  original_name: String
}

"""aggregate max on columns"""
type attachment_max_fields {
  created_at: timestamptz
  id: uuid
  mime_type: String
  original_name: String
}

"""
order by max() on columns of table "attachment"
"""
input attachment_max_order_by {
  created_at: order_by
  id: order_by
  mime_type: order_by
  original_name: order_by
}

"""aggregate min on columns"""
type attachment_min_fields {
  created_at: timestamptz
  id: uuid
  mime_type: String
  original_name: String
}

"""
order by min() on columns of table "attachment"
"""
input attachment_min_order_by {
  created_at: order_by
  id: order_by
  mime_type: order_by
  original_name: order_by
}

"""
response of any mutation on the table "attachment"
"""
type attachment_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [attachment!]!
}

"""
input type for inserting object relation for remote table "attachment"
"""
input attachment_obj_rel_insert_input {
  data: attachment_insert_input!
  on_conflict: attachment_on_conflict
}

"""
on conflict condition type for table "attachment"
"""
input attachment_on_conflict {
  constraint: attachment_constraint!
  update_columns: [attachment_update_column!]!
  where: attachment_bool_exp
}

"""
ordering options when selecting data from "attachment"
"""
input attachment_order_by {
  created_at: order_by
  id: order_by
  mime_type: order_by
  original_name: order_by
}

"""
primary key columns input for table: "attachment"
"""
input attachment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attachment"
"""
enum attachment_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  mime_type

  """column name"""
  original_name
}

"""
input type for updating data in table "attachment"
"""
input attachment_set_input {
  created_at: timestamptz
  id: uuid
  mime_type: String
  original_name: String
}

"""
update columns of table "attachment"
"""
enum attachment_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  mime_type

  """column name"""
  original_name
}

scalar json

"""
expression to compare columns of type json. All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

"""
expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "message"
"""
type message {
  content(
    """JSON select path"""
    path: String
  ): jsonb!
  created_at: timestamptz!
  id: uuid!
  is_draft: Boolean!

  """An array relationship"""
  message_attachments(
    """distinct select on columns"""
    distinct_on: [message_attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_attachments_order_by!]

    """filter the rows returned"""
    where: message_attachments_bool_exp
  ): [message_attachments!]!

  """An aggregated array relationship"""
  message_attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [message_attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_attachments_order_by!]

    """filter the rows returned"""
    where: message_attachments_bool_exp
  ): message_attachments_aggregate!

  """An object relationship"""
  message_type: message_type!

  """An object relationship"""
  topic: topic!
  topic_id: uuid!

  """An object relationship"""
  transcription: transcription
  transcription_id: uuid
  type: message_type_enum!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "message"
"""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

"""
aggregate fields of "message"
"""
type message_aggregate_fields {
  count(columns: [message_select_column!], distinct: Boolean): Int
  max: message_max_fields
  min: message_min_fields
}

"""
order by aggregate values of table "message"
"""
input message_aggregate_order_by {
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input message_append_input {
  content: jsonb
}

"""
input type for inserting array relation for remote table "message"
"""
input message_arr_rel_insert_input {
  data: [message_insert_input!]!
  on_conflict: message_on_conflict
}

"""
columns and relationships of "message_attachments"
"""
type message_attachments {
  """An object relationship"""
  attachment: attachment!
  attachment_id: uuid!

  """An object relationship"""
  message: message!
  message_id: uuid!
}

"""
aggregated selection of "message_attachments"
"""
type message_attachments_aggregate {
  aggregate: message_attachments_aggregate_fields
  nodes: [message_attachments!]!
}

"""
aggregate fields of "message_attachments"
"""
type message_attachments_aggregate_fields {
  count(columns: [message_attachments_select_column!], distinct: Boolean): Int
  max: message_attachments_max_fields
  min: message_attachments_min_fields
}

"""
order by aggregate values of table "message_attachments"
"""
input message_attachments_aggregate_order_by {
  count: order_by
  max: message_attachments_max_order_by
  min: message_attachments_min_order_by
}

"""
input type for inserting array relation for remote table "message_attachments"
"""
input message_attachments_arr_rel_insert_input {
  data: [message_attachments_insert_input!]!
  on_conflict: message_attachments_on_conflict
}

"""
Boolean expression to filter rows from the table "message_attachments". All fields are combined with a logical 'AND'.
"""
input message_attachments_bool_exp {
  _and: [message_attachments_bool_exp]
  _not: message_attachments_bool_exp
  _or: [message_attachments_bool_exp]
  attachment: attachment_bool_exp
  attachment_id: uuid_comparison_exp
  message: message_bool_exp
  message_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "message_attachments"
"""
enum message_attachments_constraint {
  """unique or primary key constraint"""
  message_attachments_pkey
}

"""
input type for inserting data into table "message_attachments"
"""
input message_attachments_insert_input {
  attachment: attachment_obj_rel_insert_input
  attachment_id: uuid
  message: message_obj_rel_insert_input
  message_id: uuid
}

"""aggregate max on columns"""
type message_attachments_max_fields {
  attachment_id: uuid
  message_id: uuid
}

"""
order by max() on columns of table "message_attachments"
"""
input message_attachments_max_order_by {
  attachment_id: order_by
  message_id: order_by
}

"""aggregate min on columns"""
type message_attachments_min_fields {
  attachment_id: uuid
  message_id: uuid
}

"""
order by min() on columns of table "message_attachments"
"""
input message_attachments_min_order_by {
  attachment_id: order_by
  message_id: order_by
}

"""
response of any mutation on the table "message_attachments"
"""
type message_attachments_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [message_attachments!]!
}

"""
input type for inserting object relation for remote table "message_attachments"
"""
input message_attachments_obj_rel_insert_input {
  data: message_attachments_insert_input!
  on_conflict: message_attachments_on_conflict
}

"""
on conflict condition type for table "message_attachments"
"""
input message_attachments_on_conflict {
  constraint: message_attachments_constraint!
  update_columns: [message_attachments_update_column!]!
  where: message_attachments_bool_exp
}

"""
ordering options when selecting data from "message_attachments"
"""
input message_attachments_order_by {
  attachment: attachment_order_by
  attachment_id: order_by
  message: message_order_by
  message_id: order_by
}

"""
primary key columns input for table: "message_attachments"
"""
input message_attachments_pk_columns_input {
  attachment_id: uuid!
  message_id: uuid!
}

"""
select columns of table "message_attachments"
"""
enum message_attachments_select_column {
  """column name"""
  attachment_id

  """column name"""
  message_id
}

"""
input type for updating data in table "message_attachments"
"""
input message_attachments_set_input {
  attachment_id: uuid
  message_id: uuid
}

"""
update columns of table "message_attachments"
"""
enum message_attachments_update_column {
  """column name"""
  attachment_id

  """column name"""
  message_id
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input message_bool_exp {
  _and: [message_bool_exp]
  _not: message_bool_exp
  _or: [message_bool_exp]
  content: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_draft: Boolean_comparison_exp
  message_attachments: message_attachments_bool_exp
  message_type: message_type_bool_exp
  topic: topic_bool_exp
  topic_id: uuid_comparison_exp
  transcription: transcription_bool_exp
  transcription_id: uuid_comparison_exp
  type: message_type_enum_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "message"
"""
enum message_constraint {
  """unique or primary key constraint"""
  message_id_key

  """unique or primary key constraint"""
  message_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input message_delete_at_path_input {
  content: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input message_delete_elem_input {
  content: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input message_delete_key_input {
  content: String
}

"""
input type for inserting data into table "message"
"""
input message_insert_input {
  content: jsonb
  created_at: timestamptz
  id: uuid
  is_draft: Boolean
  message_attachments: message_attachments_arr_rel_insert_input
  message_type: message_type_obj_rel_insert_input
  topic: topic_obj_rel_insert_input
  topic_id: uuid
  transcription: transcription_obj_rel_insert_input
  transcription_id: uuid
  type: message_type_enum
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type message_max_fields {
  created_at: timestamptz
  id: uuid
  topic_id: uuid
  transcription_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "message"
"""
input message_max_order_by {
  created_at: order_by
  id: order_by
  topic_id: order_by
  transcription_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type message_min_fields {
  created_at: timestamptz
  id: uuid
  topic_id: uuid
  transcription_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "message"
"""
input message_min_order_by {
  created_at: order_by
  id: order_by
  topic_id: order_by
  transcription_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "message"
"""
type message_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [message!]!
}

"""
input type for inserting object relation for remote table "message"
"""
input message_obj_rel_insert_input {
  data: message_insert_input!
  on_conflict: message_on_conflict
}

"""
on conflict condition type for table "message"
"""
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]!
  where: message_bool_exp
}

"""
ordering options when selecting data from "message"
"""
input message_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  is_draft: order_by
  message_attachments_aggregate: message_attachments_aggregate_order_by
  message_type: message_type_order_by
  topic: topic_order_by
  topic_id: order_by
  transcription: transcription_order_by
  transcription_id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "message"
"""
input message_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input message_prepend_input {
  content: jsonb
}

"""
select columns of table "message"
"""
enum message_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_draft

  """column name"""
  topic_id

  """column name"""
  transcription_id

  """column name"""
  type

  """column name"""
  user_id
}

"""
input type for updating data in table "message"
"""
input message_set_input {
  content: jsonb
  created_at: timestamptz
  id: uuid
  is_draft: Boolean
  topic_id: uuid
  transcription_id: uuid
  type: message_type_enum
  user_id: uuid
}

"""
Used as an ENUM for the message type field constraint.


columns and relationships of "message_type"

"""
type message_type {
  value: String!
}

"""
aggregated selection of "message_type"
"""
type message_type_aggregate {
  aggregate: message_type_aggregate_fields
  nodes: [message_type!]!
}

"""
aggregate fields of "message_type"
"""
type message_type_aggregate_fields {
  count(columns: [message_type_select_column!], distinct: Boolean): Int
  max: message_type_max_fields
  min: message_type_min_fields
}

"""
order by aggregate values of table "message_type"
"""
input message_type_aggregate_order_by {
  count: order_by
  max: message_type_max_order_by
  min: message_type_min_order_by
}

"""
input type for inserting array relation for remote table "message_type"
"""
input message_type_arr_rel_insert_input {
  data: [message_type_insert_input!]!
  on_conflict: message_type_on_conflict
}

"""
Boolean expression to filter rows from the table "message_type". All fields are combined with a logical 'AND'.
"""
input message_type_bool_exp {
  _and: [message_type_bool_exp]
  _not: message_type_bool_exp
  _or: [message_type_bool_exp]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "message_type"
"""
enum message_type_constraint {
  """unique or primary key constraint"""
  message_type_pkey
}

enum message_type_enum {
  AUDIO
  FILE
  TEXT
  VIDEO
}

"""
expression to compare columns of type message_type_enum. All fields are combined with logical 'AND'.
"""
input message_type_enum_comparison_exp {
  _eq: message_type_enum
  _in: [message_type_enum!]
  _is_null: Boolean
  _neq: message_type_enum
  _nin: [message_type_enum!]
}

"""
input type for inserting data into table "message_type"
"""
input message_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type message_type_max_fields {
  value: String
}

"""
order by max() on columns of table "message_type"
"""
input message_type_max_order_by {
  value: order_by
}

"""aggregate min on columns"""
type message_type_min_fields {
  value: String
}

"""
order by min() on columns of table "message_type"
"""
input message_type_min_order_by {
  value: order_by
}

"""
response of any mutation on the table "message_type"
"""
type message_type_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [message_type!]!
}

"""
input type for inserting object relation for remote table "message_type"
"""
input message_type_obj_rel_insert_input {
  data: message_type_insert_input!
  on_conflict: message_type_on_conflict
}

"""
on conflict condition type for table "message_type"
"""
input message_type_on_conflict {
  constraint: message_type_constraint!
  update_columns: [message_type_update_column!]!
  where: message_type_bool_exp
}

"""
ordering options when selecting data from "message_type"
"""
input message_type_order_by {
  value: order_by
}

"""
primary key columns input for table: "message_type"
"""
input message_type_pk_columns_input {
  value: String!
}

"""
select columns of table "message_type"
"""
enum message_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "message_type"
"""
input message_type_set_input {
  value: String
}

"""
update columns of table "message_type"
"""
enum message_type_update_column {
  """column name"""
  value
}

"""
update columns of table "message"
"""
enum message_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_draft

  """column name"""
  topic_id

  """column name"""
  transcription_id

  """column name"""
  type

  """column name"""
  user_id
}

"""mutation root"""
type mutation_root {
  """
  perform the action: "accept_invite"
  """
  accept_invite(code: String!): InviteAcceptResponse

  """
  delete data from the table: "account"
  """
  delete_account(
    """filter the rows which have to be deleted"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  delete single row from the table: "account"
  """
  delete_account_by_pk(id: uuid!): account

  """
  delete data from the table: "attachment"
  """
  delete_attachment(
    """filter the rows which have to be deleted"""
    where: attachment_bool_exp!
  ): attachment_mutation_response

  """
  delete single row from the table: "attachment"
  """
  delete_attachment_by_pk(id: uuid!): attachment

  """
  delete data from the table: "message"
  """
  delete_message(
    """filter the rows which have to be deleted"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  delete data from the table: "message_attachments"
  """
  delete_message_attachments(
    """filter the rows which have to be deleted"""
    where: message_attachments_bool_exp!
  ): message_attachments_mutation_response

  """
  delete single row from the table: "message_attachments"
  """
  delete_message_attachments_by_pk(attachment_id: uuid!, message_id: uuid!): message_attachments

  """
  delete single row from the table: "message"
  """
  delete_message_by_pk(id: uuid!): message

  """
  delete data from the table: "message_type"
  """
  delete_message_type(
    """filter the rows which have to be deleted"""
    where: message_type_bool_exp!
  ): message_type_mutation_response

  """
  delete single row from the table: "message_type"
  """
  delete_message_type_by_pk(value: String!): message_type

  """
  delete data from the table: "room"
  """
  delete_room(
    """filter the rows which have to be deleted"""
    where: room_bool_exp!
  ): room_mutation_response

  """
  delete single row from the table: "room"
  """
  delete_room_by_pk(id: uuid!): room

  """
  delete data from the table: "room_invites"
  """
  delete_room_invites(
    """filter the rows which have to be deleted"""
    where: room_invites_bool_exp!
  ): room_invites_mutation_response

  """
  delete single row from the table: "room_invites"
  """
  delete_room_invites_by_pk(id: uuid!): room_invites

  """
  delete data from the table: "room_participants"
  """
  delete_room_participants(
    """filter the rows which have to be deleted"""
    where: room_participants_bool_exp!
  ): room_participants_mutation_response

  """
  delete single row from the table: "room_participants"
  """
  delete_room_participants_by_pk(room_id: uuid!, user_id: uuid!): room_participants

  """
  delete data from the table: "space"
  """
  delete_space(
    """filter the rows which have to be deleted"""
    where: space_bool_exp!
  ): space_mutation_response

  """
  delete single row from the table: "space"
  """
  delete_space_by_pk(id: uuid!): space

  """
  delete data from the table: "space_participants"
  """
  delete_space_participants(
    """filter the rows which have to be deleted"""
    where: space_participants_bool_exp!
  ): space_participants_mutation_response

  """
  delete single row from the table: "space_participants"
  """
  delete_space_participants_by_pk(space_id: uuid!, user_id: uuid!): space_participants

  """
  delete data from the table: "topic"
  """
  delete_topic(
    """filter the rows which have to be deleted"""
    where: topic_bool_exp!
  ): topic_mutation_response

  """
  delete single row from the table: "topic"
  """
  delete_topic_by_pk(id: uuid!): topic

  """
  delete data from the table: "transcription"
  """
  delete_transcription(
    """filter the rows which have to be deleted"""
    where: transcription_bool_exp!
  ): transcription_mutation_response

  """
  delete single row from the table: "transcription"
  """
  delete_transcription_by_pk(id: uuid!): transcription

  """
  delete data from the table: "transcription_status"
  """
  delete_transcription_status(
    """filter the rows which have to be deleted"""
    where: transcription_status_bool_exp!
  ): transcription_status_mutation_response

  """
  delete single row from the table: "transcription_status"
  """
  delete_transcription_status_by_pk(value: String!): transcription_status

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: uuid!): user

  """
  insert data into the table: "account"
  """
  insert_account(
    """the rows to be inserted"""
    objects: [account_insert_input!]!

    """on conflict condition"""
    on_conflict: account_on_conflict
  ): account_mutation_response

  """
  insert a single row into the table: "account"
  """
  insert_account_one(
    """the row to be inserted"""
    object: account_insert_input!

    """on conflict condition"""
    on_conflict: account_on_conflict
  ): account

  """
  insert data into the table: "attachment"
  """
  insert_attachment(
    """the rows to be inserted"""
    objects: [attachment_insert_input!]!

    """on conflict condition"""
    on_conflict: attachment_on_conflict
  ): attachment_mutation_response

  """
  insert a single row into the table: "attachment"
  """
  insert_attachment_one(
    """the row to be inserted"""
    object: attachment_insert_input!

    """on conflict condition"""
    on_conflict: attachment_on_conflict
  ): attachment

  """
  insert data into the table: "message"
  """
  insert_message(
    """the rows to be inserted"""
    objects: [message_insert_input!]!

    """on conflict condition"""
    on_conflict: message_on_conflict
  ): message_mutation_response

  """
  insert data into the table: "message_attachments"
  """
  insert_message_attachments(
    """the rows to be inserted"""
    objects: [message_attachments_insert_input!]!

    """on conflict condition"""
    on_conflict: message_attachments_on_conflict
  ): message_attachments_mutation_response

  """
  insert a single row into the table: "message_attachments"
  """
  insert_message_attachments_one(
    """the row to be inserted"""
    object: message_attachments_insert_input!

    """on conflict condition"""
    on_conflict: message_attachments_on_conflict
  ): message_attachments

  """
  insert a single row into the table: "message"
  """
  insert_message_one(
    """the row to be inserted"""
    object: message_insert_input!

    """on conflict condition"""
    on_conflict: message_on_conflict
  ): message

  """
  insert data into the table: "message_type"
  """
  insert_message_type(
    """the rows to be inserted"""
    objects: [message_type_insert_input!]!

    """on conflict condition"""
    on_conflict: message_type_on_conflict
  ): message_type_mutation_response

  """
  insert a single row into the table: "message_type"
  """
  insert_message_type_one(
    """the row to be inserted"""
    object: message_type_insert_input!

    """on conflict condition"""
    on_conflict: message_type_on_conflict
  ): message_type

  """
  insert data into the table: "room"
  """
  insert_room(
    """the rows to be inserted"""
    objects: [room_insert_input!]!

    """on conflict condition"""
    on_conflict: room_on_conflict
  ): room_mutation_response

  """
  insert data into the table: "room_invites"
  """
  insert_room_invites(
    """the rows to be inserted"""
    objects: [room_invites_insert_input!]!

    """on conflict condition"""
    on_conflict: room_invites_on_conflict
  ): room_invites_mutation_response

  """
  insert a single row into the table: "room_invites"
  """
  insert_room_invites_one(
    """the row to be inserted"""
    object: room_invites_insert_input!

    """on conflict condition"""
    on_conflict: room_invites_on_conflict
  ): room_invites

  """
  insert a single row into the table: "room"
  """
  insert_room_one(
    """the row to be inserted"""
    object: room_insert_input!

    """on conflict condition"""
    on_conflict: room_on_conflict
  ): room

  """
  insert data into the table: "room_participants"
  """
  insert_room_participants(
    """the rows to be inserted"""
    objects: [room_participants_insert_input!]!

    """on conflict condition"""
    on_conflict: room_participants_on_conflict
  ): room_participants_mutation_response

  """
  insert a single row into the table: "room_participants"
  """
  insert_room_participants_one(
    """the row to be inserted"""
    object: room_participants_insert_input!

    """on conflict condition"""
    on_conflict: room_participants_on_conflict
  ): room_participants

  """
  insert data into the table: "space"
  """
  insert_space(
    """the rows to be inserted"""
    objects: [space_insert_input!]!

    """on conflict condition"""
    on_conflict: space_on_conflict
  ): space_mutation_response

  """
  insert a single row into the table: "space"
  """
  insert_space_one(
    """the row to be inserted"""
    object: space_insert_input!

    """on conflict condition"""
    on_conflict: space_on_conflict
  ): space

  """
  insert data into the table: "space_participants"
  """
  insert_space_participants(
    """the rows to be inserted"""
    objects: [space_participants_insert_input!]!

    """on conflict condition"""
    on_conflict: space_participants_on_conflict
  ): space_participants_mutation_response

  """
  insert a single row into the table: "space_participants"
  """
  insert_space_participants_one(
    """the row to be inserted"""
    object: space_participants_insert_input!

    """on conflict condition"""
    on_conflict: space_participants_on_conflict
  ): space_participants

  """
  insert data into the table: "topic"
  """
  insert_topic(
    """the rows to be inserted"""
    objects: [topic_insert_input!]!

    """on conflict condition"""
    on_conflict: topic_on_conflict
  ): topic_mutation_response

  """
  insert a single row into the table: "topic"
  """
  insert_topic_one(
    """the row to be inserted"""
    object: topic_insert_input!

    """on conflict condition"""
    on_conflict: topic_on_conflict
  ): topic

  """
  insert data into the table: "transcription"
  """
  insert_transcription(
    """the rows to be inserted"""
    objects: [transcription_insert_input!]!

    """on conflict condition"""
    on_conflict: transcription_on_conflict
  ): transcription_mutation_response

  """
  insert a single row into the table: "transcription"
  """
  insert_transcription_one(
    """the row to be inserted"""
    object: transcription_insert_input!

    """on conflict condition"""
    on_conflict: transcription_on_conflict
  ): transcription

  """
  insert data into the table: "transcription_status"
  """
  insert_transcription_status(
    """the rows to be inserted"""
    objects: [transcription_status_insert_input!]!

    """on conflict condition"""
    on_conflict: transcription_status_on_conflict
  ): transcription_status_mutation_response

  """
  insert a single row into the table: "transcription_status"
  """
  insert_transcription_status_one(
    """the row to be inserted"""
    object: transcription_status_insert_input!

    """on conflict condition"""
    on_conflict: transcription_status_on_conflict
  ): transcription_status

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "account"
  """
  update_account(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input

    """filter the rows which have to be updated"""
    where: account_bool_exp!
  ): account_mutation_response

  """
  update single row of the table: "account"
  """
  update_account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: account_set_input
    pk_columns: account_pk_columns_input!
  ): account

  """
  update data of the table: "attachment"
  """
  update_attachment(
    """sets the columns of the filtered rows to the given values"""
    _set: attachment_set_input

    """filter the rows which have to be updated"""
    where: attachment_bool_exp!
  ): attachment_mutation_response

  """
  update single row of the table: "attachment"
  """
  update_attachment_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: attachment_set_input
    pk_columns: attachment_pk_columns_input!
  ): attachment

  """
  update data of the table: "message"
  """
  update_message(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: message_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: message_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input

    """filter the rows which have to be updated"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  update data of the table: "message_attachments"
  """
  update_message_attachments(
    """sets the columns of the filtered rows to the given values"""
    _set: message_attachments_set_input

    """filter the rows which have to be updated"""
    where: message_attachments_bool_exp!
  ): message_attachments_mutation_response

  """
  update single row of the table: "message_attachments"
  """
  update_message_attachments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: message_attachments_set_input
    pk_columns: message_attachments_pk_columns_input!
  ): message_attachments

  """
  update single row of the table: "message"
  """
  update_message_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: message_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: message_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  """
  update data of the table: "message_type"
  """
  update_message_type(
    """sets the columns of the filtered rows to the given values"""
    _set: message_type_set_input

    """filter the rows which have to be updated"""
    where: message_type_bool_exp!
  ): message_type_mutation_response

  """
  update single row of the table: "message_type"
  """
  update_message_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: message_type_set_input
    pk_columns: message_type_pk_columns_input!
  ): message_type

  """
  update data of the table: "room"
  """
  update_room(
    """sets the columns of the filtered rows to the given values"""
    _set: room_set_input

    """filter the rows which have to be updated"""
    where: room_bool_exp!
  ): room_mutation_response

  """
  update single row of the table: "room"
  """
  update_room_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: room_set_input
    pk_columns: room_pk_columns_input!
  ): room

  """
  update data of the table: "room_invites"
  """
  update_room_invites(
    """sets the columns of the filtered rows to the given values"""
    _set: room_invites_set_input

    """filter the rows which have to be updated"""
    where: room_invites_bool_exp!
  ): room_invites_mutation_response

  """
  update single row of the table: "room_invites"
  """
  update_room_invites_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: room_invites_set_input
    pk_columns: room_invites_pk_columns_input!
  ): room_invites

  """
  update data of the table: "room_participants"
  """
  update_room_participants(
    """sets the columns of the filtered rows to the given values"""
    _set: room_participants_set_input

    """filter the rows which have to be updated"""
    where: room_participants_bool_exp!
  ): room_participants_mutation_response

  """
  update single row of the table: "room_participants"
  """
  update_room_participants_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: room_participants_set_input
    pk_columns: room_participants_pk_columns_input!
  ): room_participants

  """
  update data of the table: "space"
  """
  update_space(
    """sets the columns of the filtered rows to the given values"""
    _set: space_set_input

    """filter the rows which have to be updated"""
    where: space_bool_exp!
  ): space_mutation_response

  """
  update single row of the table: "space"
  """
  update_space_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: space_set_input
    pk_columns: space_pk_columns_input!
  ): space

  """
  update data of the table: "space_participants"
  """
  update_space_participants(
    """sets the columns of the filtered rows to the given values"""
    _set: space_participants_set_input

    """filter the rows which have to be updated"""
    where: space_participants_bool_exp!
  ): space_participants_mutation_response

  """
  update single row of the table: "space_participants"
  """
  update_space_participants_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: space_participants_set_input
    pk_columns: space_participants_pk_columns_input!
  ): space_participants

  """
  update data of the table: "topic"
  """
  update_topic(
    """sets the columns of the filtered rows to the given values"""
    _set: topic_set_input

    """filter the rows which have to be updated"""
    where: topic_bool_exp!
  ): topic_mutation_response

  """
  update single row of the table: "topic"
  """
  update_topic_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: topic_set_input
    pk_columns: topic_pk_columns_input!
  ): topic

  """
  update data of the table: "transcription"
  """
  update_transcription(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transcription_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transcription_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transcription_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transcription_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transcription_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transcription_set_input

    """filter the rows which have to be updated"""
    where: transcription_bool_exp!
  ): transcription_mutation_response

  """
  update single row of the table: "transcription"
  """
  update_transcription_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: transcription_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transcription_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transcription_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transcription_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: transcription_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: transcription_set_input
    pk_columns: transcription_pk_columns_input!
  ): transcription

  """
  update data of the table: "transcription_status"
  """
  update_transcription_status(
    """sets the columns of the filtered rows to the given values"""
    _set: transcription_status_set_input

    """filter the rows which have to be updated"""
    where: transcription_status_bool_exp!
  ): transcription_status_mutation_response

  """
  update single row of the table: "transcription_status"
  """
  update_transcription_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: transcription_status_set_input
    pk_columns: transcription_status_pk_columns_input!
  ): transcription_status

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  perform the action: "upgrade_current_user"
  """
  upgrade_current_user: UpgradeUserResponse
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""query root"""
type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(id: uuid!): account

  """
  fetch data from the table: "attachment"
  """
  attachment(
    """distinct select on columns"""
    distinct_on: [attachment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachment_order_by!]

    """filter the rows returned"""
    where: attachment_bool_exp
  ): [attachment!]!

  """
  fetch aggregated fields from the table: "attachment"
  """
  attachment_aggregate(
    """distinct select on columns"""
    distinct_on: [attachment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachment_order_by!]

    """filter the rows returned"""
    where: attachment_bool_exp
  ): attachment_aggregate!

  """fetch data from the table: "attachment" using primary key columns"""
  attachment_by_pk(id: uuid!): attachment

  """
  perform the action: "get_download_url"
  """
  get_download_url(uuid: uuid!): GetDownloadUrlResponse

  """
  perform the action: "get_upload_url"
  """
  get_upload_url(fileName: String!, mimeType: String!): GetUploadUrlResponse

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "message_attachments"
  """
  message_attachments(
    """distinct select on columns"""
    distinct_on: [message_attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_attachments_order_by!]

    """filter the rows returned"""
    where: message_attachments_bool_exp
  ): [message_attachments!]!

  """
  fetch aggregated fields from the table: "message_attachments"
  """
  message_attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [message_attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_attachments_order_by!]

    """filter the rows returned"""
    where: message_attachments_bool_exp
  ): message_attachments_aggregate!

  """
  fetch data from the table: "message_attachments" using primary key columns
  """
  message_attachments_by_pk(attachment_id: uuid!, message_id: uuid!): message_attachments

  """fetch data from the table: "message" using primary key columns"""
  message_by_pk(id: uuid!): message

  """
  fetch data from the table: "message_type"
  """
  message_type(
    """distinct select on columns"""
    distinct_on: [message_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_type_order_by!]

    """filter the rows returned"""
    where: message_type_bool_exp
  ): [message_type!]!

  """
  fetch aggregated fields from the table: "message_type"
  """
  message_type_aggregate(
    """distinct select on columns"""
    distinct_on: [message_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_type_order_by!]

    """filter the rows returned"""
    where: message_type_bool_exp
  ): message_type_aggregate!

  """fetch data from the table: "message_type" using primary key columns"""
  message_type_by_pk(value: String!): message_type

  """
  fetch data from the table: "room"
  """
  room(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """
  fetch aggregated fields from the table: "room"
  """
  room_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!

  """fetch data from the table: "room" using primary key columns"""
  room_by_pk(id: uuid!): room

  """
  fetch data from the table: "room_invites"
  """
  room_invites(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): [room_invites!]!

  """
  fetch aggregated fields from the table: "room_invites"
  """
  room_invites_aggregate(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): room_invites_aggregate!

  """fetch data from the table: "room_invites" using primary key columns"""
  room_invites_by_pk(id: uuid!): room_invites

  """
  fetch data from the table: "room_participants"
  """
  room_participants(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): [room_participants!]!

  """
  fetch aggregated fields from the table: "room_participants"
  """
  room_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): room_participants_aggregate!

  """
  fetch data from the table: "room_participants" using primary key columns
  """
  room_participants_by_pk(room_id: uuid!, user_id: uuid!): room_participants

  """
  fetch data from the table: "space"
  """
  space(
    """distinct select on columns"""
    distinct_on: [space_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_order_by!]

    """filter the rows returned"""
    where: space_bool_exp
  ): [space!]!

  """
  fetch aggregated fields from the table: "space"
  """
  space_aggregate(
    """distinct select on columns"""
    distinct_on: [space_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_order_by!]

    """filter the rows returned"""
    where: space_bool_exp
  ): space_aggregate!

  """fetch data from the table: "space" using primary key columns"""
  space_by_pk(id: uuid!): space

  """
  fetch data from the table: "space_participants"
  """
  space_participants(
    """distinct select on columns"""
    distinct_on: [space_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_participants_order_by!]

    """filter the rows returned"""
    where: space_participants_bool_exp
  ): [space_participants!]!

  """
  fetch aggregated fields from the table: "space_participants"
  """
  space_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [space_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_participants_order_by!]

    """filter the rows returned"""
    where: space_participants_bool_exp
  ): space_participants_aggregate!

  """
  fetch data from the table: "space_participants" using primary key columns
  """
  space_participants_by_pk(space_id: uuid!, user_id: uuid!): space_participants

  """
  fetch data from the table: "topic"
  """
  topic(
    """distinct select on columns"""
    distinct_on: [topic_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topic_order_by!]

    """filter the rows returned"""
    where: topic_bool_exp
  ): [topic!]!

  """
  fetch aggregated fields from the table: "topic"
  """
  topic_aggregate(
    """distinct select on columns"""
    distinct_on: [topic_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topic_order_by!]

    """filter the rows returned"""
    where: topic_bool_exp
  ): topic_aggregate!

  """fetch data from the table: "topic" using primary key columns"""
  topic_by_pk(id: uuid!): topic

  """
  fetch data from the table: "transcription"
  """
  transcription(
    """distinct select on columns"""
    distinct_on: [transcription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_order_by!]

    """filter the rows returned"""
    where: transcription_bool_exp
  ): [transcription!]!

  """
  fetch aggregated fields from the table: "transcription"
  """
  transcription_aggregate(
    """distinct select on columns"""
    distinct_on: [transcription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_order_by!]

    """filter the rows returned"""
    where: transcription_bool_exp
  ): transcription_aggregate!

  """fetch data from the table: "transcription" using primary key columns"""
  transcription_by_pk(id: uuid!): transcription

  """
  fetch data from the table: "transcription_status"
  """
  transcription_status(
    """distinct select on columns"""
    distinct_on: [transcription_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_status_order_by!]

    """filter the rows returned"""
    where: transcription_status_bool_exp
  ): [transcription_status!]!

  """
  fetch aggregated fields from the table: "transcription_status"
  """
  transcription_status_aggregate(
    """distinct select on columns"""
    distinct_on: [transcription_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_status_order_by!]

    """filter the rows returned"""
    where: transcription_status_bool_exp
  ): transcription_status_aggregate!

  """
  fetch data from the table: "transcription_status" using primary key columns
  """
  transcription_status_by_pk(value: String!): transcription_status

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user
}

"""
columns and relationships of "room"
"""
type room {
  created_at: timestamptz!

  """An object relationship"""
  creator: user!
  creator_id: uuid!
  deadline: timestamptz!
  finished_at: timestamptz
  id: uuid!
  name: String
  notification_job_id: String

  """An array relationship"""
  participants(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): [room_participants!]!

  """An aggregated array relationship"""
  participants_aggregate(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): room_participants_aggregate!

  """An array relationship"""
  room_invites(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): [room_invites!]!

  """An aggregated array relationship"""
  room_invites_aggregate(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): room_invites_aggregate!

  """An object relationship"""
  space: space
  space_id: uuid
  summary: String

  """An array relationship"""
  topics(
    """distinct select on columns"""
    distinct_on: [topic_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topic_order_by!]

    """filter the rows returned"""
    where: topic_bool_exp
  ): [topic!]!

  """An aggregated array relationship"""
  topics_aggregate(
    """distinct select on columns"""
    distinct_on: [topic_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topic_order_by!]

    """filter the rows returned"""
    where: topic_bool_exp
  ): topic_aggregate!
}

"""
aggregated selection of "room"
"""
type room_aggregate {
  aggregate: room_aggregate_fields
  nodes: [room!]!
}

"""
aggregate fields of "room"
"""
type room_aggregate_fields {
  count(columns: [room_select_column!], distinct: Boolean): Int
  max: room_max_fields
  min: room_min_fields
}

"""
order by aggregate values of table "room"
"""
input room_aggregate_order_by {
  count: order_by
  max: room_max_order_by
  min: room_min_order_by
}

"""
input type for inserting array relation for remote table "room"
"""
input room_arr_rel_insert_input {
  data: [room_insert_input!]!
  on_conflict: room_on_conflict
}

"""
Boolean expression to filter rows from the table "room". All fields are combined with a logical 'AND'.
"""
input room_bool_exp {
  _and: [room_bool_exp]
  _not: room_bool_exp
  _or: [room_bool_exp]
  created_at: timestamptz_comparison_exp
  creator: user_bool_exp
  creator_id: uuid_comparison_exp
  deadline: timestamptz_comparison_exp
  finished_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  notification_job_id: String_comparison_exp
  participants: room_participants_bool_exp
  room_invites: room_invites_bool_exp
  space: space_bool_exp
  space_id: uuid_comparison_exp
  summary: String_comparison_exp
  topics: topic_bool_exp
}

"""
unique or primary key constraints on table "room"
"""
enum room_constraint {
  """unique or primary key constraint"""
  room_pkey
}

"""
input type for inserting data into table "room"
"""
input room_insert_input {
  created_at: timestamptz
  creator: user_obj_rel_insert_input
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  name: String
  notification_job_id: String
  participants: room_participants_arr_rel_insert_input
  room_invites: room_invites_arr_rel_insert_input
  space: space_obj_rel_insert_input
  space_id: uuid
  summary: String
  topics: topic_arr_rel_insert_input
}

"""
columns and relationships of "room_invites"
"""
type room_invites {
  code: uuid!
  created_at: timestamptz!
  email: String!
  id: uuid!

  """An object relationship"""
  inviter: user!
  inviter_id: uuid!

  """An object relationship"""
  room: room!
  room_id: uuid!
  used_at: timestamptz
}

"""
aggregated selection of "room_invites"
"""
type room_invites_aggregate {
  aggregate: room_invites_aggregate_fields
  nodes: [room_invites!]!
}

"""
aggregate fields of "room_invites"
"""
type room_invites_aggregate_fields {
  count(columns: [room_invites_select_column!], distinct: Boolean): Int
  max: room_invites_max_fields
  min: room_invites_min_fields
}

"""
order by aggregate values of table "room_invites"
"""
input room_invites_aggregate_order_by {
  count: order_by
  max: room_invites_max_order_by
  min: room_invites_min_order_by
}

"""
input type for inserting array relation for remote table "room_invites"
"""
input room_invites_arr_rel_insert_input {
  data: [room_invites_insert_input!]!
  on_conflict: room_invites_on_conflict
}

"""
Boolean expression to filter rows from the table "room_invites". All fields are combined with a logical 'AND'.
"""
input room_invites_bool_exp {
  _and: [room_invites_bool_exp]
  _not: room_invites_bool_exp
  _or: [room_invites_bool_exp]
  code: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  inviter: user_bool_exp
  inviter_id: uuid_comparison_exp
  room: room_bool_exp
  room_id: uuid_comparison_exp
  used_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "room_invites"
"""
enum room_invites_constraint {
  """unique or primary key constraint"""
  room_invites_code_key

  """unique or primary key constraint"""
  room_invites_pkey

  """unique or primary key constraint"""
  room_invites_room_id_email_key
}

"""
input type for inserting data into table "room_invites"
"""
input room_invites_insert_input {
  code: uuid
  created_at: timestamptz
  email: String
  id: uuid
  inviter: user_obj_rel_insert_input
  inviter_id: uuid
  room: room_obj_rel_insert_input
  room_id: uuid
  used_at: timestamptz
}

"""aggregate max on columns"""
type room_invites_max_fields {
  code: uuid
  created_at: timestamptz
  email: String
  id: uuid
  inviter_id: uuid
  room_id: uuid
  used_at: timestamptz
}

"""
order by max() on columns of table "room_invites"
"""
input room_invites_max_order_by {
  code: order_by
  created_at: order_by
  email: order_by
  id: order_by
  inviter_id: order_by
  room_id: order_by
  used_at: order_by
}

"""aggregate min on columns"""
type room_invites_min_fields {
  code: uuid
  created_at: timestamptz
  email: String
  id: uuid
  inviter_id: uuid
  room_id: uuid
  used_at: timestamptz
}

"""
order by min() on columns of table "room_invites"
"""
input room_invites_min_order_by {
  code: order_by
  created_at: order_by
  email: order_by
  id: order_by
  inviter_id: order_by
  room_id: order_by
  used_at: order_by
}

"""
response of any mutation on the table "room_invites"
"""
type room_invites_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [room_invites!]!
}

"""
input type for inserting object relation for remote table "room_invites"
"""
input room_invites_obj_rel_insert_input {
  data: room_invites_insert_input!
  on_conflict: room_invites_on_conflict
}

"""
on conflict condition type for table "room_invites"
"""
input room_invites_on_conflict {
  constraint: room_invites_constraint!
  update_columns: [room_invites_update_column!]!
  where: room_invites_bool_exp
}

"""
ordering options when selecting data from "room_invites"
"""
input room_invites_order_by {
  code: order_by
  created_at: order_by
  email: order_by
  id: order_by
  inviter: user_order_by
  inviter_id: order_by
  room: room_order_by
  room_id: order_by
  used_at: order_by
}

"""
primary key columns input for table: "room_invites"
"""
input room_invites_pk_columns_input {
  id: uuid!
}

"""
select columns of table "room_invites"
"""
enum room_invites_select_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  inviter_id

  """column name"""
  room_id

  """column name"""
  used_at
}

"""
input type for updating data in table "room_invites"
"""
input room_invites_set_input {
  code: uuid
  created_at: timestamptz
  email: String
  id: uuid
  inviter_id: uuid
  room_id: uuid
  used_at: timestamptz
}

"""
update columns of table "room_invites"
"""
enum room_invites_update_column {
  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  inviter_id

  """column name"""
  room_id

  """column name"""
  used_at
}

"""aggregate max on columns"""
type room_max_fields {
  created_at: timestamptz
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  name: String
  notification_job_id: String
  space_id: uuid
  summary: String
}

"""
order by max() on columns of table "room"
"""
input room_max_order_by {
  created_at: order_by
  creator_id: order_by
  deadline: order_by
  finished_at: order_by
  id: order_by
  name: order_by
  notification_job_id: order_by
  space_id: order_by
  summary: order_by
}

"""aggregate min on columns"""
type room_min_fields {
  created_at: timestamptz
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  name: String
  notification_job_id: String
  space_id: uuid
  summary: String
}

"""
order by min() on columns of table "room"
"""
input room_min_order_by {
  created_at: order_by
  creator_id: order_by
  deadline: order_by
  finished_at: order_by
  id: order_by
  name: order_by
  notification_job_id: order_by
  space_id: order_by
  summary: order_by
}

"""
response of any mutation on the table "room"
"""
type room_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [room!]!
}

"""
input type for inserting object relation for remote table "room"
"""
input room_obj_rel_insert_input {
  data: room_insert_input!
  on_conflict: room_on_conflict
}

"""
on conflict condition type for table "room"
"""
input room_on_conflict {
  constraint: room_constraint!
  update_columns: [room_update_column!]!
  where: room_bool_exp
}

"""
ordering options when selecting data from "room"
"""
input room_order_by {
  created_at: order_by
  creator: user_order_by
  creator_id: order_by
  deadline: order_by
  finished_at: order_by
  id: order_by
  name: order_by
  notification_job_id: order_by
  participants_aggregate: room_participants_aggregate_order_by
  room_invites_aggregate: room_invites_aggregate_order_by
  space: space_order_by
  space_id: order_by
  summary: order_by
  topics_aggregate: topic_aggregate_order_by
}

"""
columns and relationships of "room_participants"
"""
type room_participants {
  """An object relationship"""
  room: room!
  room_id: uuid!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "room_participants"
"""
type room_participants_aggregate {
  aggregate: room_participants_aggregate_fields
  nodes: [room_participants!]!
}

"""
aggregate fields of "room_participants"
"""
type room_participants_aggregate_fields {
  count(columns: [room_participants_select_column!], distinct: Boolean): Int
  max: room_participants_max_fields
  min: room_participants_min_fields
}

"""
order by aggregate values of table "room_participants"
"""
input room_participants_aggregate_order_by {
  count: order_by
  max: room_participants_max_order_by
  min: room_participants_min_order_by
}

"""
input type for inserting array relation for remote table "room_participants"
"""
input room_participants_arr_rel_insert_input {
  data: [room_participants_insert_input!]!
  on_conflict: room_participants_on_conflict
}

"""
Boolean expression to filter rows from the table "room_participants". All fields are combined with a logical 'AND'.
"""
input room_participants_bool_exp {
  _and: [room_participants_bool_exp]
  _not: room_participants_bool_exp
  _or: [room_participants_bool_exp]
  room: room_bool_exp
  room_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "room_participants"
"""
enum room_participants_constraint {
  """unique or primary key constraint"""
  room_participants_pkey

  """unique or primary key constraint"""
  room_participants_room_id_user_id_key
}

"""
input type for inserting data into table "room_participants"
"""
input room_participants_insert_input {
  room: room_obj_rel_insert_input
  room_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type room_participants_max_fields {
  room_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "room_participants"
"""
input room_participants_max_order_by {
  room_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type room_participants_min_fields {
  room_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "room_participants"
"""
input room_participants_min_order_by {
  room_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "room_participants"
"""
type room_participants_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [room_participants!]!
}

"""
input type for inserting object relation for remote table "room_participants"
"""
input room_participants_obj_rel_insert_input {
  data: room_participants_insert_input!
  on_conflict: room_participants_on_conflict
}

"""
on conflict condition type for table "room_participants"
"""
input room_participants_on_conflict {
  constraint: room_participants_constraint!
  update_columns: [room_participants_update_column!]!
  where: room_participants_bool_exp
}

"""
ordering options when selecting data from "room_participants"
"""
input room_participants_order_by {
  room: room_order_by
  room_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "room_participants"
"""
input room_participants_pk_columns_input {
  room_id: uuid!
  user_id: uuid!
}

"""
select columns of table "room_participants"
"""
enum room_participants_select_column {
  """column name"""
  room_id

  """column name"""
  user_id
}

"""
input type for updating data in table "room_participants"
"""
input room_participants_set_input {
  room_id: uuid
  user_id: uuid
}

"""
update columns of table "room_participants"
"""
enum room_participants_update_column {
  """column name"""
  room_id

  """column name"""
  user_id
}

"""
primary key columns input for table: "room"
"""
input room_pk_columns_input {
  id: uuid!
}

"""
select columns of table "room"
"""
enum room_select_column {
  """column name"""
  created_at

  """column name"""
  creator_id

  """column name"""
  deadline

  """column name"""
  finished_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  notification_job_id

  """column name"""
  space_id

  """column name"""
  summary
}

"""
input type for updating data in table "room"
"""
input room_set_input {
  created_at: timestamptz
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  name: String
  notification_job_id: String
  space_id: uuid
  summary: String
}

"""
update columns of table "room"
"""
enum room_update_column {
  """column name"""
  created_at

  """column name"""
  creator_id

  """column name"""
  deadline

  """column name"""
  finished_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  notification_job_id

  """column name"""
  space_id

  """column name"""
  summary
}

"""
columns and relationships of "space"
"""
type space {
  """An object relationship"""
  creator: user
  creator_id: uuid!
  id: uuid!
  name: String!

  """An array relationship"""
  participants(
    """distinct select on columns"""
    distinct_on: [space_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_participants_order_by!]

    """filter the rows returned"""
    where: space_participants_bool_exp
  ): [space_participants!]!

  """An aggregated array relationship"""
  participants_aggregate(
    """distinct select on columns"""
    distinct_on: [space_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_participants_order_by!]

    """filter the rows returned"""
    where: space_participants_bool_exp
  ): space_participants_aggregate!

  """An array relationship"""
  rooms(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """An aggregated array relationship"""
  rooms_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!
}

"""
aggregated selection of "space"
"""
type space_aggregate {
  aggregate: space_aggregate_fields
  nodes: [space!]!
}

"""
aggregate fields of "space"
"""
type space_aggregate_fields {
  count(columns: [space_select_column!], distinct: Boolean): Int
  max: space_max_fields
  min: space_min_fields
}

"""
order by aggregate values of table "space"
"""
input space_aggregate_order_by {
  count: order_by
  max: space_max_order_by
  min: space_min_order_by
}

"""
input type for inserting array relation for remote table "space"
"""
input space_arr_rel_insert_input {
  data: [space_insert_input!]!
  on_conflict: space_on_conflict
}

"""
Boolean expression to filter rows from the table "space". All fields are combined with a logical 'AND'.
"""
input space_bool_exp {
  _and: [space_bool_exp]
  _not: space_bool_exp
  _or: [space_bool_exp]
  creator: user_bool_exp
  creator_id: uuid_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  participants: space_participants_bool_exp
  rooms: room_bool_exp
}

"""
unique or primary key constraints on table "space"
"""
enum space_constraint {
  """unique or primary key constraint"""
  space_pkey
}

"""
input type for inserting data into table "space"
"""
input space_insert_input {
  creator: user_obj_rel_insert_input
  creator_id: uuid
  id: uuid
  name: String
  participants: space_participants_arr_rel_insert_input
  rooms: room_arr_rel_insert_input
}

"""aggregate max on columns"""
type space_max_fields {
  creator_id: uuid
  id: uuid
  name: String
}

"""
order by max() on columns of table "space"
"""
input space_max_order_by {
  creator_id: order_by
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type space_min_fields {
  creator_id: uuid
  id: uuid
  name: String
}

"""
order by min() on columns of table "space"
"""
input space_min_order_by {
  creator_id: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "space"
"""
type space_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [space!]!
}

"""
input type for inserting object relation for remote table "space"
"""
input space_obj_rel_insert_input {
  data: space_insert_input!
  on_conflict: space_on_conflict
}

"""
on conflict condition type for table "space"
"""
input space_on_conflict {
  constraint: space_constraint!
  update_columns: [space_update_column!]!
  where: space_bool_exp
}

"""
ordering options when selecting data from "space"
"""
input space_order_by {
  creator: user_order_by
  creator_id: order_by
  id: order_by
  name: order_by
  participants_aggregate: space_participants_aggregate_order_by
  rooms_aggregate: room_aggregate_order_by
}

"""
columns and relationships of "space_participants"
"""
type space_participants {
  """An object relationship"""
  space: space!
  space_id: uuid!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "space_participants"
"""
type space_participants_aggregate {
  aggregate: space_participants_aggregate_fields
  nodes: [space_participants!]!
}

"""
aggregate fields of "space_participants"
"""
type space_participants_aggregate_fields {
  count(columns: [space_participants_select_column!], distinct: Boolean): Int
  max: space_participants_max_fields
  min: space_participants_min_fields
}

"""
order by aggregate values of table "space_participants"
"""
input space_participants_aggregate_order_by {
  count: order_by
  max: space_participants_max_order_by
  min: space_participants_min_order_by
}

"""
input type for inserting array relation for remote table "space_participants"
"""
input space_participants_arr_rel_insert_input {
  data: [space_participants_insert_input!]!
  on_conflict: space_participants_on_conflict
}

"""
Boolean expression to filter rows from the table "space_participants". All fields are combined with a logical 'AND'.
"""
input space_participants_bool_exp {
  _and: [space_participants_bool_exp]
  _not: space_participants_bool_exp
  _or: [space_participants_bool_exp]
  space: space_bool_exp
  space_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "space_participants"
"""
enum space_participants_constraint {
  """unique or primary key constraint"""
  space_participants_pkey
}

"""
input type for inserting data into table "space_participants"
"""
input space_participants_insert_input {
  space: space_obj_rel_insert_input
  space_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type space_participants_max_fields {
  space_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "space_participants"
"""
input space_participants_max_order_by {
  space_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type space_participants_min_fields {
  space_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "space_participants"
"""
input space_participants_min_order_by {
  space_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "space_participants"
"""
type space_participants_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [space_participants!]!
}

"""
input type for inserting object relation for remote table "space_participants"
"""
input space_participants_obj_rel_insert_input {
  data: space_participants_insert_input!
  on_conflict: space_participants_on_conflict
}

"""
on conflict condition type for table "space_participants"
"""
input space_participants_on_conflict {
  constraint: space_participants_constraint!
  update_columns: [space_participants_update_column!]!
  where: space_participants_bool_exp
}

"""
ordering options when selecting data from "space_participants"
"""
input space_participants_order_by {
  space: space_order_by
  space_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "space_participants"
"""
input space_participants_pk_columns_input {
  space_id: uuid!
  user_id: uuid!
}

"""
select columns of table "space_participants"
"""
enum space_participants_select_column {
  """column name"""
  space_id

  """column name"""
  user_id
}

"""
input type for updating data in table "space_participants"
"""
input space_participants_set_input {
  space_id: uuid
  user_id: uuid
}

"""
update columns of table "space_participants"
"""
enum space_participants_update_column {
  """column name"""
  space_id

  """column name"""
  user_id
}

"""
primary key columns input for table: "space"
"""
input space_pk_columns_input {
  id: uuid!
}

"""
select columns of table "space"
"""
enum space_select_column {
  """column name"""
  creator_id

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "space"
"""
input space_set_input {
  creator_id: uuid
  id: uuid
  name: String
}

"""
update columns of table "space"
"""
enum space_update_column {
  """column name"""
  creator_id

  """column name"""
  id

  """column name"""
  name
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(id: uuid!): account

  """
  fetch data from the table: "attachment"
  """
  attachment(
    """distinct select on columns"""
    distinct_on: [attachment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachment_order_by!]

    """filter the rows returned"""
    where: attachment_bool_exp
  ): [attachment!]!

  """
  fetch aggregated fields from the table: "attachment"
  """
  attachment_aggregate(
    """distinct select on columns"""
    distinct_on: [attachment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachment_order_by!]

    """filter the rows returned"""
    where: attachment_bool_exp
  ): attachment_aggregate!

  """fetch data from the table: "attachment" using primary key columns"""
  attachment_by_pk(id: uuid!): attachment

  """
  perform the action: "get_download_url"
  """
  get_download_url(uuid: uuid!): GetDownloadUrlResponse

  """
  perform the action: "get_upload_url"
  """
  get_upload_url(fileName: String!, mimeType: String!): GetUploadUrlResponse

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "message_attachments"
  """
  message_attachments(
    """distinct select on columns"""
    distinct_on: [message_attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_attachments_order_by!]

    """filter the rows returned"""
    where: message_attachments_bool_exp
  ): [message_attachments!]!

  """
  fetch aggregated fields from the table: "message_attachments"
  """
  message_attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [message_attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_attachments_order_by!]

    """filter the rows returned"""
    where: message_attachments_bool_exp
  ): message_attachments_aggregate!

  """
  fetch data from the table: "message_attachments" using primary key columns
  """
  message_attachments_by_pk(attachment_id: uuid!, message_id: uuid!): message_attachments

  """fetch data from the table: "message" using primary key columns"""
  message_by_pk(id: uuid!): message

  """
  fetch data from the table: "message_type"
  """
  message_type(
    """distinct select on columns"""
    distinct_on: [message_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_type_order_by!]

    """filter the rows returned"""
    where: message_type_bool_exp
  ): [message_type!]!

  """
  fetch aggregated fields from the table: "message_type"
  """
  message_type_aggregate(
    """distinct select on columns"""
    distinct_on: [message_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_type_order_by!]

    """filter the rows returned"""
    where: message_type_bool_exp
  ): message_type_aggregate!

  """fetch data from the table: "message_type" using primary key columns"""
  message_type_by_pk(value: String!): message_type

  """
  fetch data from the table: "room"
  """
  room(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """
  fetch aggregated fields from the table: "room"
  """
  room_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!

  """fetch data from the table: "room" using primary key columns"""
  room_by_pk(id: uuid!): room

  """
  fetch data from the table: "room_invites"
  """
  room_invites(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): [room_invites!]!

  """
  fetch aggregated fields from the table: "room_invites"
  """
  room_invites_aggregate(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): room_invites_aggregate!

  """fetch data from the table: "room_invites" using primary key columns"""
  room_invites_by_pk(id: uuid!): room_invites

  """
  fetch data from the table: "room_participants"
  """
  room_participants(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): [room_participants!]!

  """
  fetch aggregated fields from the table: "room_participants"
  """
  room_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): room_participants_aggregate!

  """
  fetch data from the table: "room_participants" using primary key columns
  """
  room_participants_by_pk(room_id: uuid!, user_id: uuid!): room_participants

  """
  fetch data from the table: "space"
  """
  space(
    """distinct select on columns"""
    distinct_on: [space_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_order_by!]

    """filter the rows returned"""
    where: space_bool_exp
  ): [space!]!

  """
  fetch aggregated fields from the table: "space"
  """
  space_aggregate(
    """distinct select on columns"""
    distinct_on: [space_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_order_by!]

    """filter the rows returned"""
    where: space_bool_exp
  ): space_aggregate!

  """fetch data from the table: "space" using primary key columns"""
  space_by_pk(id: uuid!): space

  """
  fetch data from the table: "space_participants"
  """
  space_participants(
    """distinct select on columns"""
    distinct_on: [space_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_participants_order_by!]

    """filter the rows returned"""
    where: space_participants_bool_exp
  ): [space_participants!]!

  """
  fetch aggregated fields from the table: "space_participants"
  """
  space_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [space_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [space_participants_order_by!]

    """filter the rows returned"""
    where: space_participants_bool_exp
  ): space_participants_aggregate!

  """
  fetch data from the table: "space_participants" using primary key columns
  """
  space_participants_by_pk(space_id: uuid!, user_id: uuid!): space_participants

  """
  fetch data from the table: "topic"
  """
  topic(
    """distinct select on columns"""
    distinct_on: [topic_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topic_order_by!]

    """filter the rows returned"""
    where: topic_bool_exp
  ): [topic!]!

  """
  fetch aggregated fields from the table: "topic"
  """
  topic_aggregate(
    """distinct select on columns"""
    distinct_on: [topic_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [topic_order_by!]

    """filter the rows returned"""
    where: topic_bool_exp
  ): topic_aggregate!

  """fetch data from the table: "topic" using primary key columns"""
  topic_by_pk(id: uuid!): topic

  """
  fetch data from the table: "transcription"
  """
  transcription(
    """distinct select on columns"""
    distinct_on: [transcription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_order_by!]

    """filter the rows returned"""
    where: transcription_bool_exp
  ): [transcription!]!

  """
  fetch aggregated fields from the table: "transcription"
  """
  transcription_aggregate(
    """distinct select on columns"""
    distinct_on: [transcription_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_order_by!]

    """filter the rows returned"""
    where: transcription_bool_exp
  ): transcription_aggregate!

  """fetch data from the table: "transcription" using primary key columns"""
  transcription_by_pk(id: uuid!): transcription

  """
  fetch data from the table: "transcription_status"
  """
  transcription_status(
    """distinct select on columns"""
    distinct_on: [transcription_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_status_order_by!]

    """filter the rows returned"""
    where: transcription_status_bool_exp
  ): [transcription_status!]!

  """
  fetch aggregated fields from the table: "transcription_status"
  """
  transcription_status_aggregate(
    """distinct select on columns"""
    distinct_on: [transcription_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transcription_status_order_by!]

    """filter the rows returned"""
    where: transcription_status_bool_exp
  ): transcription_status_aggregate!

  """
  fetch data from the table: "transcription_status" using primary key columns
  """
  transcription_status_by_pk(value: String!): transcription_status

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "topic"
"""
type topic {
  id: uuid!
  index: String!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """An aggregated array relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!
  name: String

  """An object relationship"""
  room: room!
  room_id: uuid!
}

"""
aggregated selection of "topic"
"""
type topic_aggregate {
  aggregate: topic_aggregate_fields
  nodes: [topic!]!
}

"""
aggregate fields of "topic"
"""
type topic_aggregate_fields {
  count(columns: [topic_select_column!], distinct: Boolean): Int
  max: topic_max_fields
  min: topic_min_fields
}

"""
order by aggregate values of table "topic"
"""
input topic_aggregate_order_by {
  count: order_by
  max: topic_max_order_by
  min: topic_min_order_by
}

"""
input type for inserting array relation for remote table "topic"
"""
input topic_arr_rel_insert_input {
  data: [topic_insert_input!]!
  on_conflict: topic_on_conflict
}

"""
Boolean expression to filter rows from the table "topic". All fields are combined with a logical 'AND'.
"""
input topic_bool_exp {
  _and: [topic_bool_exp]
  _not: topic_bool_exp
  _or: [topic_bool_exp]
  id: uuid_comparison_exp
  index: String_comparison_exp
  messages: message_bool_exp
  name: String_comparison_exp
  room: room_bool_exp
  room_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "topic"
"""
enum topic_constraint {
  """unique or primary key constraint"""
  thread_pkey
}

"""
input type for inserting data into table "topic"
"""
input topic_insert_input {
  id: uuid
  index: String
  messages: message_arr_rel_insert_input
  name: String
  room: room_obj_rel_insert_input
  room_id: uuid
}

"""aggregate max on columns"""
type topic_max_fields {
  id: uuid
  index: String
  name: String
  room_id: uuid
}

"""
order by max() on columns of table "topic"
"""
input topic_max_order_by {
  id: order_by
  index: order_by
  name: order_by
  room_id: order_by
}

"""aggregate min on columns"""
type topic_min_fields {
  id: uuid
  index: String
  name: String
  room_id: uuid
}

"""
order by min() on columns of table "topic"
"""
input topic_min_order_by {
  id: order_by
  index: order_by
  name: order_by
  room_id: order_by
}

"""
response of any mutation on the table "topic"
"""
type topic_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [topic!]!
}

"""
input type for inserting object relation for remote table "topic"
"""
input topic_obj_rel_insert_input {
  data: topic_insert_input!
  on_conflict: topic_on_conflict
}

"""
on conflict condition type for table "topic"
"""
input topic_on_conflict {
  constraint: topic_constraint!
  update_columns: [topic_update_column!]!
  where: topic_bool_exp
}

"""
ordering options when selecting data from "topic"
"""
input topic_order_by {
  id: order_by
  index: order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  room: room_order_by
  room_id: order_by
}

"""
primary key columns input for table: "topic"
"""
input topic_pk_columns_input {
  id: uuid!
}

"""
select columns of table "topic"
"""
enum topic_select_column {
  """column name"""
  id

  """column name"""
  index

  """column name"""
  name

  """column name"""
  room_id
}

"""
input type for updating data in table "topic"
"""
input topic_set_input {
  id: uuid
  index: String
  name: String
  room_id: uuid
}

"""
update columns of table "topic"
"""
enum topic_update_column {
  """column name"""
  id

  """column name"""
  index

  """column name"""
  name

  """column name"""
  room_id
}

"""
columns and relationships of "transcription"
"""
type transcription {
  created_at: timestamptz!
  id: uuid!
  sonix_media_id: String!
  status: transcription_status_enum!
  transcript(
    """JSON select path"""
    path: String
  ): jsonb
  updated_at: timestamptz!
}

"""
aggregated selection of "transcription"
"""
type transcription_aggregate {
  aggregate: transcription_aggregate_fields
  nodes: [transcription!]!
}

"""
aggregate fields of "transcription"
"""
type transcription_aggregate_fields {
  count(columns: [transcription_select_column!], distinct: Boolean): Int
  max: transcription_max_fields
  min: transcription_min_fields
}

"""
order by aggregate values of table "transcription"
"""
input transcription_aggregate_order_by {
  count: order_by
  max: transcription_max_order_by
  min: transcription_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input transcription_append_input {
  transcript: jsonb
}

"""
input type for inserting array relation for remote table "transcription"
"""
input transcription_arr_rel_insert_input {
  data: [transcription_insert_input!]!
  on_conflict: transcription_on_conflict
}

"""
Boolean expression to filter rows from the table "transcription". All fields are combined with a logical 'AND'.
"""
input transcription_bool_exp {
  _and: [transcription_bool_exp]
  _not: transcription_bool_exp
  _or: [transcription_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  sonix_media_id: String_comparison_exp
  status: transcription_status_enum_comparison_exp
  transcript: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "transcription"
"""
enum transcription_constraint {
  """unique or primary key constraint"""
  transcription_pkey

  """unique or primary key constraint"""
  transcription_sonix_media_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input transcription_delete_at_path_input {
  transcript: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input transcription_delete_elem_input {
  transcript: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input transcription_delete_key_input {
  transcript: String
}

"""
input type for inserting data into table "transcription"
"""
input transcription_insert_input {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  status: transcription_status_enum
  transcript: jsonb
  updated_at: timestamptz
}

"""aggregate max on columns"""
type transcription_max_fields {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "transcription"
"""
input transcription_max_order_by {
  created_at: order_by
  id: order_by
  sonix_media_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type transcription_min_fields {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "transcription"
"""
input transcription_min_order_by {
  created_at: order_by
  id: order_by
  sonix_media_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "transcription"
"""
type transcription_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [transcription!]!
}

"""
input type for inserting object relation for remote table "transcription"
"""
input transcription_obj_rel_insert_input {
  data: transcription_insert_input!
  on_conflict: transcription_on_conflict
}

"""
on conflict condition type for table "transcription"
"""
input transcription_on_conflict {
  constraint: transcription_constraint!
  update_columns: [transcription_update_column!]!
  where: transcription_bool_exp
}

"""
ordering options when selecting data from "transcription"
"""
input transcription_order_by {
  created_at: order_by
  id: order_by
  sonix_media_id: order_by
  status: order_by
  transcript: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "transcription"
"""
input transcription_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input transcription_prepend_input {
  transcript: jsonb
}

"""
select columns of table "transcription"
"""
enum transcription_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  sonix_media_id

  """column name"""
  status

  """column name"""
  transcript

  """column name"""
  updated_at
}

"""
input type for updating data in table "transcription"
"""
input transcription_set_input {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  status: transcription_status_enum
  transcript: jsonb
  updated_at: timestamptz
}

"""
columns and relationships of "transcription_status"
"""
type transcription_status {
  value: String!
}

"""
aggregated selection of "transcription_status"
"""
type transcription_status_aggregate {
  aggregate: transcription_status_aggregate_fields
  nodes: [transcription_status!]!
}

"""
aggregate fields of "transcription_status"
"""
type transcription_status_aggregate_fields {
  count(columns: [transcription_status_select_column!], distinct: Boolean): Int
  max: transcription_status_max_fields
  min: transcription_status_min_fields
}

"""
order by aggregate values of table "transcription_status"
"""
input transcription_status_aggregate_order_by {
  count: order_by
  max: transcription_status_max_order_by
  min: transcription_status_min_order_by
}

"""
input type for inserting array relation for remote table "transcription_status"
"""
input transcription_status_arr_rel_insert_input {
  data: [transcription_status_insert_input!]!
  on_conflict: transcription_status_on_conflict
}

"""
Boolean expression to filter rows from the table "transcription_status". All fields are combined with a logical 'AND'.
"""
input transcription_status_bool_exp {
  _and: [transcription_status_bool_exp]
  _not: transcription_status_bool_exp
  _or: [transcription_status_bool_exp]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "transcription_status"
"""
enum transcription_status_constraint {
  """unique or primary key constraint"""
  transcription_status_pkey
}

enum transcription_status_enum {
  blocked
  completed
  failed
  preparing
  transcribing
}

"""
expression to compare columns of type transcription_status_enum. All fields are combined with logical 'AND'.
"""
input transcription_status_enum_comparison_exp {
  _eq: transcription_status_enum
  _in: [transcription_status_enum!]
  _is_null: Boolean
  _neq: transcription_status_enum
  _nin: [transcription_status_enum!]
}

"""
input type for inserting data into table "transcription_status"
"""
input transcription_status_insert_input {
  value: String
}

"""aggregate max on columns"""
type transcription_status_max_fields {
  value: String
}

"""
order by max() on columns of table "transcription_status"
"""
input transcription_status_max_order_by {
  value: order_by
}

"""aggregate min on columns"""
type transcription_status_min_fields {
  value: String
}

"""
order by min() on columns of table "transcription_status"
"""
input transcription_status_min_order_by {
  value: order_by
}

"""
response of any mutation on the table "transcription_status"
"""
type transcription_status_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [transcription_status!]!
}

"""
input type for inserting object relation for remote table "transcription_status"
"""
input transcription_status_obj_rel_insert_input {
  data: transcription_status_insert_input!
  on_conflict: transcription_status_on_conflict
}

"""
on conflict condition type for table "transcription_status"
"""
input transcription_status_on_conflict {
  constraint: transcription_status_constraint!
  update_columns: [transcription_status_update_column!]!
  where: transcription_status_bool_exp
}

"""
ordering options when selecting data from "transcription_status"
"""
input transcription_status_order_by {
  value: order_by
}

"""
primary key columns input for table: "transcription_status"
"""
input transcription_status_pk_columns_input {
  value: String!
}

"""
select columns of table "transcription_status"
"""
enum transcription_status_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "transcription_status"
"""
input transcription_status_set_input {
  value: String
}

"""
update columns of table "transcription_status"
"""
enum transcription_status_update_column {
  """column name"""
  value
}

"""
update columns of table "transcription"
"""
enum transcription_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  sonix_media_id

  """column name"""
  status

  """column name"""
  transcript

  """column name"""
  updated_at
}

"""
columns and relationships of "user"
"""
type user {
  avatar_url: String
  created_at: timestamptz!

  """An array relationship"""
  created_rooms(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): [room!]!

  """An aggregated array relationship"""
  created_rooms_aggregate(
    """distinct select on columns"""
    distinct_on: [room_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_order_by!]

    """filter the rows returned"""
    where: room_bool_exp
  ): room_aggregate!
  email: String
  email_verified: timestamptz
  id: uuid!

  """An array relationship"""
  invites(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): [room_invites!]!

  """An aggregated array relationship"""
  invites_aggregate(
    """distinct select on columns"""
    distinct_on: [room_invites_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_invites_order_by!]

    """filter the rows returned"""
    where: room_invites_bool_exp
  ): room_invites_aggregate!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """An aggregated array relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!
  name: String

  """An array relationship"""
  rooms(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): [room_participants!]!

  """An aggregated array relationship"""
  rooms_aggregate(
    """distinct select on columns"""
    distinct_on: [room_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [room_participants_order_by!]

    """filter the rows returned"""
    where: room_participants_bool_exp
  ): room_participants_aggregate!
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  avatar_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_rooms: room_bool_exp
  email: String_comparison_exp
  email_verified: timestamptz_comparison_exp
  id: uuid_comparison_exp
  invites: room_invites_bool_exp
  messages: message_bool_exp
  name: String_comparison_exp
  rooms: room_participants_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """unique or primary key constraint"""
  user_email_key

  """unique or primary key constraint"""
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  avatar_url: String
  created_at: timestamptz
  created_rooms: room_arr_rel_insert_input
  email: String
  email_verified: timestamptz
  id: uuid
  invites: room_invites_arr_rel_insert_input
  messages: message_arr_rel_insert_input
  name: String
  rooms: room_participants_arr_rel_insert_input
}

"""aggregate max on columns"""
type user_max_fields {
  avatar_url: String
  created_at: timestamptz
  email: String
  email_verified: timestamptz
  id: uuid
  name: String
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  avatar_url: order_by
  created_at: order_by
  email: order_by
  email_verified: order_by
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  avatar_url: String
  created_at: timestamptz
  email: String
  email_verified: timestamptz
  id: uuid
  name: String
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  avatar_url: order_by
  created_at: order_by
  email: order_by
  email_verified: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
ordering options when selecting data from "user"
"""
input user_order_by {
  avatar_url: order_by
  created_at: order_by
  created_rooms_aggregate: room_aggregate_order_by
  email: order_by
  email_verified: order_by
  id: order_by
  invites_aggregate: room_invites_aggregate_order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  rooms_aggregate: room_participants_aggregate_order_by
}

"""
primary key columns input for table: "user"
"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  avatar_url

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_verified

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  avatar_url: String
  created_at: timestamptz
  email: String
  email_verified: timestamptz
  id: uuid
  name: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  avatar_url

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_verified

  """column name"""
  id

  """column name"""
  name
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
