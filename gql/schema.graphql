schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type DownloadUrlResponse {
  downloadUrl: String!
}

type LookupTeamNameResponse {
  inviter_name: String!
  team_name: String!
}

type RoomInvitationViewResponse {
  inviter_name: String!
  room_name: String!
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

type UpgradeUserResponse {
  user: user
  user_id: ID!
}

type UploadUrlResponse {
  uploadUrl: String!
  uuid: ID!
}

"""
Account represents 3rd party login methods used by given user.


columns and relationships of "account"
"""
type account {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz!
  id: uuid!
  provider_account_id: String!
  provider_id: String!
  provider_type: String!
  refresh_token: String
  updated_at: timestamptz!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "account"
"""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"""
aggregate fields of "account"
"""
type account_aggregate_fields {
  count(columns: [account_select_column!], distinct: Boolean): Int
  max: account_max_fields
  min: account_min_fields
}

"""
order by aggregate values of table "account"
"""
input account_aggregate_order_by {
  count: order_by
  max: account_max_order_by
  min: account_min_order_by
}

"""
input type for inserting array relation for remote table "account"
"""
input account_arr_rel_insert_input {
  data: [account_insert_input!]!
  on_conflict: account_on_conflict
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input account_bool_exp {
  _and: [account_bool_exp]
  _not: account_bool_exp
  _or: [account_bool_exp]
  access_token: String_comparison_exp
  access_token_expires: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider_account_id: String_comparison_exp
  provider_id: String_comparison_exp
  provider_type: String_comparison_exp
  refresh_token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "account"
"""
enum account_constraint {
  """
  unique or primary key constraint
  """
  account_pkey
}

"""
input type for inserting data into table "account"
"""
input account_insert_input {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type account_max_fields {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "account"
"""
input account_max_order_by {
  access_token: order_by
  access_token_expires: order_by
  created_at: order_by
  id: order_by
  provider_account_id: order_by
  provider_id: order_by
  provider_type: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type account_min_fields {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "account"
"""
input account_min_order_by {
  access_token: order_by
  access_token_expires: order_by
  created_at: order_by
  id: order_by
  provider_account_id: order_by
  provider_id: order_by
  provider_type: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "account"
"""
type account_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [account!]!
}

"""
input type for inserting object relation for remote table "account"
"""
input account_obj_rel_insert_input {
  data: account_insert_input!
  on_conflict: account_on_conflict
}

"""
on conflict condition type for table "account"
"""
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]!
  where: account_bool_exp
}

"""
ordering options when selecting data from "account"
"""
input account_order_by {
  access_token: order_by
  access_token_expires: order_by
  created_at: order_by
  id: order_by
  provider_account_id: order_by
  provider_id: order_by
  provider_type: order_by
  refresh_token: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "account"
"""
input account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "account"
"""
enum account_select_column {
  """
  column name
  """
  access_token

  """
  column name
  """
  access_token_expires

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  provider_account_id

  """
  column name
  """
  provider_id

  """
  column name
  """
  provider_type

  """
  column name
  """
  refresh_token

  """
  column name
  """
  updated_at

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "account"
"""
input account_set_input {
  access_token: String
  access_token_expires: timestamptz
  created_at: timestamptz
  id: uuid
  provider_account_id: String
  provider_id: String
  provider_type: String
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "account"
"""
enum account_update_column {
  """
  column name
  """
  access_token

  """
  column name
  """
  access_token_expires

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  provider_account_id

  """
  column name
  """
  provider_id

  """
  column name
  """
  provider_type

  """
  column name
  """
  refresh_token

  """
  column name
  """
  updated_at

  """
  column name
  """
  user_id
}

"""
columns and relationships of "attachment"
"""
type attachment {
  created_at: timestamptz!
  id: uuid!

  """
  An object relationship
  """
  message: message
  message_id: uuid
  mime_type: String!
  original_name: String!

  """
  An object relationship
  """
  transcription: transcription
  transcription_id: uuid
}

"""
aggregated selection of "attachment"
"""
type attachment_aggregate {
  aggregate: attachment_aggregate_fields
  nodes: [attachment!]!
}

"""
aggregate fields of "attachment"
"""
type attachment_aggregate_fields {
  count(columns: [attachment_select_column!], distinct: Boolean): Int
  max: attachment_max_fields
  min: attachment_min_fields
}

"""
order by aggregate values of table "attachment"
"""
input attachment_aggregate_order_by {
  count: order_by
  max: attachment_max_order_by
  min: attachment_min_order_by
}

"""
input type for inserting array relation for remote table "attachment"
"""
input attachment_arr_rel_insert_input {
  data: [attachment_insert_input!]!
  on_conflict: attachment_on_conflict
}

"""
Boolean expression to filter rows from the table "attachment". All fields are combined with a logical 'AND'.
"""
input attachment_bool_exp {
  _and: [attachment_bool_exp]
  _not: attachment_bool_exp
  _or: [attachment_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  message: message_bool_exp
  message_id: uuid_comparison_exp
  mime_type: String_comparison_exp
  original_name: String_comparison_exp
  transcription: transcription_bool_exp
  transcription_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "attachment"
"""
enum attachment_constraint {
  """
  unique or primary key constraint
  """
  attachment_id_key

  """
  unique or primary key constraint
  """
  attachment_pkey
}

"""
input type for inserting data into table "attachment"
"""
input attachment_insert_input {
  created_at: timestamptz
  id: uuid
  message: message_obj_rel_insert_input
  message_id: uuid
  mime_type: String
  original_name: String
  transcription: transcription_obj_rel_insert_input
  transcription_id: uuid
}

"""
aggregate max on columns
"""
type attachment_max_fields {
  created_at: timestamptz
  id: uuid
  message_id: uuid
  mime_type: String
  original_name: String
  transcription_id: uuid
}

"""
order by max() on columns of table "attachment"
"""
input attachment_max_order_by {
  created_at: order_by
  id: order_by
  message_id: order_by
  mime_type: order_by
  original_name: order_by
  transcription_id: order_by
}

"""
aggregate min on columns
"""
type attachment_min_fields {
  created_at: timestamptz
  id: uuid
  message_id: uuid
  mime_type: String
  original_name: String
  transcription_id: uuid
}

"""
order by min() on columns of table "attachment"
"""
input attachment_min_order_by {
  created_at: order_by
  id: order_by
  message_id: order_by
  mime_type: order_by
  original_name: order_by
  transcription_id: order_by
}

"""
response of any mutation on the table "attachment"
"""
type attachment_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [attachment!]!
}

"""
input type for inserting object relation for remote table "attachment"
"""
input attachment_obj_rel_insert_input {
  data: attachment_insert_input!
  on_conflict: attachment_on_conflict
}

"""
on conflict condition type for table "attachment"
"""
input attachment_on_conflict {
  constraint: attachment_constraint!
  update_columns: [attachment_update_column!]!
  where: attachment_bool_exp
}

"""
ordering options when selecting data from "attachment"
"""
input attachment_order_by {
  created_at: order_by
  id: order_by
  message: message_order_by
  message_id: order_by
  mime_type: order_by
  original_name: order_by
  transcription: transcription_order_by
  transcription_id: order_by
}

"""
primary key columns input for table: "attachment"
"""
input attachment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "attachment"
"""
enum attachment_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  message_id

  """
  column name
  """
  mime_type

  """
  column name
  """
  original_name

  """
  column name
  """
  transcription_id
}

"""
input type for updating data in table "attachment"
"""
input attachment_set_input {
  created_at: timestamptz
  id: uuid
  message_id: uuid
  mime_type: String
  original_name: String
  transcription_id: uuid
}

"""
update columns of table "attachment"
"""
enum attachment_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  message_id

  """
  column name
  """
  mime_type

  """
  column name
  """
  original_name

  """
  column name
  """
  transcription_id
}

scalar bigint

"""
expression to compare columns of type bigint. All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

scalar date

"""
expression to compare columns of type date. All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

scalar json

"""
expression to compare columns of type json. All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

"""
expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "last_seen_message"
"""
type last_seen_message {
  message_id: uuid!
  seen_at: timestamptz!
  topic_id: uuid!
  user_id: uuid!
}

"""
aggregated selection of "last_seen_message"
"""
type last_seen_message_aggregate {
  aggregate: last_seen_message_aggregate_fields
  nodes: [last_seen_message!]!
}

"""
aggregate fields of "last_seen_message"
"""
type last_seen_message_aggregate_fields {
  count(columns: [last_seen_message_select_column!], distinct: Boolean): Int
  max: last_seen_message_max_fields
  min: last_seen_message_min_fields
}

"""
order by aggregate values of table "last_seen_message"
"""
input last_seen_message_aggregate_order_by {
  count: order_by
  max: last_seen_message_max_order_by
  min: last_seen_message_min_order_by
}

"""
input type for inserting array relation for remote table "last_seen_message"
"""
input last_seen_message_arr_rel_insert_input {
  data: [last_seen_message_insert_input!]!
  on_conflict: last_seen_message_on_conflict
}

"""
Boolean expression to filter rows from the table "last_seen_message". All fields are combined with a logical 'AND'.
"""
input last_seen_message_bool_exp {
  _and: [last_seen_message_bool_exp]
  _not: last_seen_message_bool_exp
  _or: [last_seen_message_bool_exp]
  message_id: uuid_comparison_exp
  seen_at: timestamptz_comparison_exp
  topic_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "last_seen_message"
"""
enum last_seen_message_constraint {
  """
  unique or primary key constraint
  """
  last_seen_message_pkey
}

"""
input type for inserting data into table "last_seen_message"
"""
input last_seen_message_insert_input {
  message_id: uuid
  seen_at: timestamptz
  topic_id: uuid
  user_id: uuid
}

"""
aggregate max on columns
"""
type last_seen_message_max_fields {
  message_id: uuid
  seen_at: timestamptz
  topic_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "last_seen_message"
"""
input last_seen_message_max_order_by {
  message_id: order_by
  seen_at: order_by
  topic_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type last_seen_message_min_fields {
  message_id: uuid
  seen_at: timestamptz
  topic_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "last_seen_message"
"""
input last_seen_message_min_order_by {
  message_id: order_by
  seen_at: order_by
  topic_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "last_seen_message"
"""
type last_seen_message_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [last_seen_message!]!
}

"""
input type for inserting object relation for remote table "last_seen_message"
"""
input last_seen_message_obj_rel_insert_input {
  data: last_seen_message_insert_input!
  on_conflict: last_seen_message_on_conflict
}

"""
on conflict condition type for table "last_seen_message"
"""
input last_seen_message_on_conflict {
  constraint: last_seen_message_constraint!
  update_columns: [last_seen_message_update_column!]!
  where: last_seen_message_bool_exp
}

"""
ordering options when selecting data from "last_seen_message"
"""
input last_seen_message_order_by {
  message_id: order_by
  seen_at: order_by
  topic_id: order_by
  user_id: order_by
}

"""
primary key columns input for table: "last_seen_message"
"""
input last_seen_message_pk_columns_input {
  topic_id: uuid!
  user_id: uuid!
}

"""
select columns of table "last_seen_message"
"""
enum last_seen_message_select_column {
  """
  column name
  """
  message_id

  """
  column name
  """
  seen_at

  """
  column name
  """
  topic_id

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "last_seen_message"
"""
input last_seen_message_set_input {
  message_id: uuid
  seen_at: timestamptz
  topic_id: uuid
  user_id: uuid
}

"""
update columns of table "last_seen_message"
"""
enum last_seen_message_update_column {
  """
  column name
  """
  message_id

  """
  column name
  """
  seen_at

  """
  column name
  """
  topic_id

  """
  column name
  """
  user_id
}

"""
columns and relationships of "membership_status"
"""
type membership_status {
  value: String!
}

"""
aggregated selection of "membership_status"
"""
type membership_status_aggregate {
  aggregate: membership_status_aggregate_fields
  nodes: [membership_status!]!
}

"""
aggregate fields of "membership_status"
"""
type membership_status_aggregate_fields {
  count(columns: [membership_status_select_column!], distinct: Boolean): Int
  max: membership_status_max_fields
  min: membership_status_min_fields
}

"""
order by aggregate values of table "membership_status"
"""
input membership_status_aggregate_order_by {
  count: order_by
  max: membership_status_max_order_by
  min: membership_status_min_order_by
}

"""
input type for inserting array relation for remote table "membership_status"
"""
input membership_status_arr_rel_insert_input {
  data: [membership_status_insert_input!]!
  on_conflict: membership_status_on_conflict
}

"""
Boolean expression to filter rows from the table "membership_status". All fields are combined with a logical 'AND'.
"""
input membership_status_bool_exp {
  _and: [membership_status_bool_exp]
  _not: membership_status_bool_exp
  _or: [membership_status_bool_exp]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "membership_status"
"""
enum membership_status_constraint {
  """
  unique or primary key constraint
  """
  team_membership_status_pkey
}

"""
input type for inserting data into table "membership_status"
"""
input membership_status_insert_input {
  value: String
}

"""
aggregate max on columns
"""
type membership_status_max_fields {
  value: String
}

"""
order by max() on columns of table "membership_status"
"""
input membership_status_max_order_by {
  value: order_by
}

"""
aggregate min on columns
"""
type membership_status_min_fields {
  value: String
}

"""
order by min() on columns of table "membership_status"
"""
input membership_status_min_order_by {
  value: order_by
}

"""
response of any mutation on the table "membership_status"
"""
type membership_status_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [membership_status!]!
}

"""
input type for inserting object relation for remote table "membership_status"
"""
input membership_status_obj_rel_insert_input {
  data: membership_status_insert_input!
  on_conflict: membership_status_on_conflict
}

"""
on conflict condition type for table "membership_status"
"""
input membership_status_on_conflict {
  constraint: membership_status_constraint!
  update_columns: [membership_status_update_column!]!
  where: membership_status_bool_exp
}

"""
ordering options when selecting data from "membership_status"
"""
input membership_status_order_by {
  value: order_by
}

"""
primary key columns input for table: "membership_status"
"""
input membership_status_pk_columns_input {
  value: String!
}

"""
select columns of table "membership_status"
"""
enum membership_status_select_column {
  """
  column name
  """
  value
}

"""
input type for updating data in table "membership_status"
"""
input membership_status_set_input {
  value: String
}

"""
update columns of table "membership_status"
"""
enum membership_status_update_column {
  """
  column name
  """
  value
}

"""
columns and relationships of "message"
"""
type message {
  content(
    """
    JSON select path
    """
    path: String
  ): jsonb!
  content_text: String
  created_at: timestamptz!
  id: uuid!
  is_draft: Boolean!

  """
  An array relationship
  """
  message_attachments(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): [attachment!]!

  """
  An aggregated array relationship
  """
  message_attachments_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): attachment_aggregate!

  """
  An array relationship
  """
  message_reactions(
    """
    distinct select on columns
    """
    distinct_on: [message_reaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_reaction_order_by!]

    """
    filter the rows returned
    """
    where: message_reaction_bool_exp
  ): [message_reaction!]!

  """
  An aggregated array relationship
  """
  message_reactions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_reaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_reaction_order_by!]

    """
    filter the rows returned
    """
    where: message_reaction_bool_exp
  ): message_reaction_aggregate!

  """
  An object relationship
  """
  message_type: message_type!

  """
  An object relationship
  """
  replied_to_message: message
  replied_to_message_id: uuid

  """
  An object relationship
  """
  topic: topic!
  topic_id: uuid!
  type: message_type_enum!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "message"
"""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

"""
aggregate fields of "message"
"""
type message_aggregate_fields {
  count(columns: [message_select_column!], distinct: Boolean): Int
  max: message_max_fields
  min: message_min_fields
}

"""
order by aggregate values of table "message"
"""
input message_aggregate_order_by {
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input message_append_input {
  content: jsonb
}

"""
input type for inserting array relation for remote table "message"
"""
input message_arr_rel_insert_input {
  data: [message_insert_input!]!
  on_conflict: message_on_conflict
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input message_bool_exp {
  _and: [message_bool_exp]
  _not: message_bool_exp
  _or: [message_bool_exp]
  content: jsonb_comparison_exp
  content_text: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  is_draft: Boolean_comparison_exp
  message_attachments: attachment_bool_exp
  message_reactions: message_reaction_bool_exp
  message_type: message_type_bool_exp
  replied_to_message: message_bool_exp
  replied_to_message_id: uuid_comparison_exp
  topic: topic_bool_exp
  topic_id: uuid_comparison_exp
  type: message_type_enum_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "message"
"""
enum message_constraint {
  """
  unique or primary key constraint
  """
  message_id_key

  """
  unique or primary key constraint
  """
  message_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input message_delete_at_path_input {
  content: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input message_delete_elem_input {
  content: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input message_delete_key_input {
  content: String
}

"""
input type for inserting data into table "message"
"""
input message_insert_input {
  content: jsonb
  content_text: String
  created_at: timestamptz
  id: uuid
  is_draft: Boolean
  message_attachments: attachment_arr_rel_insert_input
  message_reactions: message_reaction_arr_rel_insert_input
  message_type: message_type_obj_rel_insert_input
  replied_to_message: message_obj_rel_insert_input
  replied_to_message_id: uuid
  topic: topic_obj_rel_insert_input
  topic_id: uuid
  type: message_type_enum
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type message_max_fields {
  content_text: String
  created_at: timestamptz
  id: uuid
  replied_to_message_id: uuid
  topic_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "message"
"""
input message_max_order_by {
  content_text: order_by
  created_at: order_by
  id: order_by
  replied_to_message_id: order_by
  topic_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type message_min_fields {
  content_text: String
  created_at: timestamptz
  id: uuid
  replied_to_message_id: uuid
  topic_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "message"
"""
input message_min_order_by {
  content_text: order_by
  created_at: order_by
  id: order_by
  replied_to_message_id: order_by
  topic_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "message"
"""
type message_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [message!]!
}

"""
input type for inserting object relation for remote table "message"
"""
input message_obj_rel_insert_input {
  data: message_insert_input!
  on_conflict: message_on_conflict
}

"""
on conflict condition type for table "message"
"""
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]!
  where: message_bool_exp
}

"""
ordering options when selecting data from "message"
"""
input message_order_by {
  content: order_by
  content_text: order_by
  created_at: order_by
  id: order_by
  is_draft: order_by
  message_attachments_aggregate: attachment_aggregate_order_by
  message_reactions_aggregate: message_reaction_aggregate_order_by
  message_type: message_type_order_by
  replied_to_message: message_order_by
  replied_to_message_id: order_by
  topic: topic_order_by
  topic_id: order_by
  type: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "message"
"""
input message_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input message_prepend_input {
  content: jsonb
}

"""
columns and relationships of "message_reaction"
"""
type message_reaction {
  emoji: String!

  """
  An object relationship
  """
  message: message!
  message_id: uuid!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "message_reaction"
"""
type message_reaction_aggregate {
  aggregate: message_reaction_aggregate_fields
  nodes: [message_reaction!]!
}

"""
aggregate fields of "message_reaction"
"""
type message_reaction_aggregate_fields {
  count(columns: [message_reaction_select_column!], distinct: Boolean): Int
  max: message_reaction_max_fields
  min: message_reaction_min_fields
}

"""
order by aggregate values of table "message_reaction"
"""
input message_reaction_aggregate_order_by {
  count: order_by
  max: message_reaction_max_order_by
  min: message_reaction_min_order_by
}

"""
input type for inserting array relation for remote table "message_reaction"
"""
input message_reaction_arr_rel_insert_input {
  data: [message_reaction_insert_input!]!
  on_conflict: message_reaction_on_conflict
}

"""
Boolean expression to filter rows from the table "message_reaction". All fields are combined with a logical 'AND'.
"""
input message_reaction_bool_exp {
  _and: [message_reaction_bool_exp]
  _not: message_reaction_bool_exp
  _or: [message_reaction_bool_exp]
  emoji: String_comparison_exp
  message: message_bool_exp
  message_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "message_reaction"
"""
enum message_reaction_constraint {
  """
  unique or primary key constraint
  """
  message_reaction_pkey
}

"""
input type for inserting data into table "message_reaction"
"""
input message_reaction_insert_input {
  emoji: String
  message: message_obj_rel_insert_input
  message_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type message_reaction_max_fields {
  emoji: String
  message_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "message_reaction"
"""
input message_reaction_max_order_by {
  emoji: order_by
  message_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type message_reaction_min_fields {
  emoji: String
  message_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "message_reaction"
"""
input message_reaction_min_order_by {
  emoji: order_by
  message_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "message_reaction"
"""
type message_reaction_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [message_reaction!]!
}

"""
input type for inserting object relation for remote table "message_reaction"
"""
input message_reaction_obj_rel_insert_input {
  data: message_reaction_insert_input!
  on_conflict: message_reaction_on_conflict
}

"""
on conflict condition type for table "message_reaction"
"""
input message_reaction_on_conflict {
  constraint: message_reaction_constraint!
  update_columns: [message_reaction_update_column!]!
  where: message_reaction_bool_exp
}

"""
ordering options when selecting data from "message_reaction"
"""
input message_reaction_order_by {
  emoji: order_by
  message: message_order_by
  message_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "message_reaction"
"""
input message_reaction_pk_columns_input {
  emoji: String!
  message_id: uuid!
  user_id: uuid!
}

"""
select columns of table "message_reaction"
"""
enum message_reaction_select_column {
  """
  column name
  """
  emoji

  """
  column name
  """
  message_id

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "message_reaction"
"""
input message_reaction_set_input {
  emoji: String
  message_id: uuid
  user_id: uuid
}

"""
update columns of table "message_reaction"
"""
enum message_reaction_update_column {
  """
  column name
  """
  emoji

  """
  column name
  """
  message_id

  """
  column name
  """
  user_id
}

"""
select columns of table "message"
"""
enum message_select_column {
  """
  column name
  """
  content

  """
  column name
  """
  content_text

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  is_draft

  """
  column name
  """
  replied_to_message_id

  """
  column name
  """
  topic_id

  """
  column name
  """
  type

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "message"
"""
input message_set_input {
  content: jsonb
  content_text: String
  created_at: timestamptz
  id: uuid
  is_draft: Boolean
  replied_to_message_id: uuid
  topic_id: uuid
  type: message_type_enum
  user_id: uuid
}

"""
Used as an ENUM for the message type field constraint.


columns and relationships of "message_type"
"""
type message_type {
  value: String!
}

"""
aggregated selection of "message_type"
"""
type message_type_aggregate {
  aggregate: message_type_aggregate_fields
  nodes: [message_type!]!
}

"""
aggregate fields of "message_type"
"""
type message_type_aggregate_fields {
  count(columns: [message_type_select_column!], distinct: Boolean): Int
  max: message_type_max_fields
  min: message_type_min_fields
}

"""
order by aggregate values of table "message_type"
"""
input message_type_aggregate_order_by {
  count: order_by
  max: message_type_max_order_by
  min: message_type_min_order_by
}

"""
input type for inserting array relation for remote table "message_type"
"""
input message_type_arr_rel_insert_input {
  data: [message_type_insert_input!]!
  on_conflict: message_type_on_conflict
}

"""
Boolean expression to filter rows from the table "message_type". All fields are combined with a logical 'AND'.
"""
input message_type_bool_exp {
  _and: [message_type_bool_exp]
  _not: message_type_bool_exp
  _or: [message_type_bool_exp]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "message_type"
"""
enum message_type_constraint {
  """
  unique or primary key constraint
  """
  message_type_pkey
}

enum message_type_enum {
  AUDIO
  FILE
  TEXT
  VIDEO
}

"""
expression to compare columns of type message_type_enum. All fields are combined with logical 'AND'.
"""
input message_type_enum_comparison_exp {
  _eq: message_type_enum
  _in: [message_type_enum!]
  _is_null: Boolean
  _neq: message_type_enum
  _nin: [message_type_enum!]
}

"""
input type for inserting data into table "message_type"
"""
input message_type_insert_input {
  value: String
}

"""
aggregate max on columns
"""
type message_type_max_fields {
  value: String
}

"""
order by max() on columns of table "message_type"
"""
input message_type_max_order_by {
  value: order_by
}

"""
aggregate min on columns
"""
type message_type_min_fields {
  value: String
}

"""
order by min() on columns of table "message_type"
"""
input message_type_min_order_by {
  value: order_by
}

"""
response of any mutation on the table "message_type"
"""
type message_type_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [message_type!]!
}

"""
input type for inserting object relation for remote table "message_type"
"""
input message_type_obj_rel_insert_input {
  data: message_type_insert_input!
  on_conflict: message_type_on_conflict
}

"""
on conflict condition type for table "message_type"
"""
input message_type_on_conflict {
  constraint: message_type_constraint!
  update_columns: [message_type_update_column!]!
  where: message_type_bool_exp
}

"""
ordering options when selecting data from "message_type"
"""
input message_type_order_by {
  value: order_by
}

"""
primary key columns input for table: "message_type"
"""
input message_type_pk_columns_input {
  value: String!
}

"""
select columns of table "message_type"
"""
enum message_type_select_column {
  """
  column name
  """
  value
}

"""
input type for updating data in table "message_type"
"""
input message_type_set_input {
  value: String
}

"""
update columns of table "message_type"
"""
enum message_type_update_column {
  """
  column name
  """
  value
}

"""
update columns of table "message"
"""
enum message_update_column {
  """
  column name
  """
  content

  """
  column name
  """
  content_text

  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  is_draft

  """
  column name
  """
  replied_to_message_id

  """
  column name
  """
  topic_id

  """
  column name
  """
  type

  """
  column name
  """
  user_id
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "account"
  """
  delete_account(
    """
    filter the rows which have to be deleted
    """
    where: account_bool_exp!
  ): account_mutation_response

  """
  delete single row from the table: "account"
  """
  delete_account_by_pk(id: uuid!): account

  """
  delete data from the table: "attachment"
  """
  delete_attachment(
    """
    filter the rows which have to be deleted
    """
    where: attachment_bool_exp!
  ): attachment_mutation_response

  """
  delete single row from the table: "attachment"
  """
  delete_attachment_by_pk(id: uuid!): attachment

  """
  delete data from the table: "last_seen_message"
  """
  delete_last_seen_message(
    """
    filter the rows which have to be deleted
    """
    where: last_seen_message_bool_exp!
  ): last_seen_message_mutation_response

  """
  delete single row from the table: "last_seen_message"
  """
  delete_last_seen_message_by_pk(topic_id: uuid!, user_id: uuid!): last_seen_message

  """
  delete data from the table: "membership_status"
  """
  delete_membership_status(
    """
    filter the rows which have to be deleted
    """
    where: membership_status_bool_exp!
  ): membership_status_mutation_response

  """
  delete single row from the table: "membership_status"
  """
  delete_membership_status_by_pk(value: String!): membership_status

  """
  delete data from the table: "message"
  """
  delete_message(
    """
    filter the rows which have to be deleted
    """
    where: message_bool_exp!
  ): message_mutation_response

  """
  delete single row from the table: "message"
  """
  delete_message_by_pk(id: uuid!): message

  """
  delete data from the table: "message_reaction"
  """
  delete_message_reaction(
    """
    filter the rows which have to be deleted
    """
    where: message_reaction_bool_exp!
  ): message_reaction_mutation_response

  """
  delete single row from the table: "message_reaction"
  """
  delete_message_reaction_by_pk(emoji: String!, message_id: uuid!, user_id: uuid!): message_reaction

  """
  delete data from the table: "message_type"
  """
  delete_message_type(
    """
    filter the rows which have to be deleted
    """
    where: message_type_bool_exp!
  ): message_type_mutation_response

  """
  delete single row from the table: "message_type"
  """
  delete_message_type_by_pk(value: String!): message_type

  """
  delete data from the table: "notification"
  """
  delete_notification(
    """
    filter the rows which have to be deleted
    """
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  delete single row from the table: "notification"
  """
  delete_notification_by_pk(id: uuid!): notification

  """
  delete data from the table: "room"
  """
  delete_room(
    """
    filter the rows which have to be deleted
    """
    where: room_bool_exp!
  ): room_mutation_response

  """
  delete single row from the table: "room"
  """
  delete_room_by_pk(id: uuid!): room

  """
  delete data from the table: "room_invitation"
  """
  delete_room_invitation(
    """
    filter the rows which have to be deleted
    """
    where: room_invitation_bool_exp!
  ): room_invitation_mutation_response

  """
  delete single row from the table: "room_invitation"
  """
  delete_room_invitation_by_pk(id: uuid!): room_invitation

  """
  delete data from the table: "room_member"
  """
  delete_room_member(
    """
    filter the rows which have to be deleted
    """
    where: room_member_bool_exp!
  ): room_member_mutation_response

  """
  delete single row from the table: "room_member"
  """
  delete_room_member_by_pk(room_id: uuid!, user_id: uuid!): room_member

  """
  delete data from the table: "space"
  """
  delete_space(
    """
    filter the rows which have to be deleted
    """
    where: space_bool_exp!
  ): space_mutation_response

  """
  delete single row from the table: "space"
  """
  delete_space_by_pk(id: uuid!): space

  """
  delete data from the table: "space_member"
  """
  delete_space_member(
    """
    filter the rows which have to be deleted
    """
    where: space_member_bool_exp!
  ): space_member_mutation_response

  """
  delete single row from the table: "space_member"
  """
  delete_space_member_by_pk(space_id: uuid!, user_id: uuid!): space_member

  """
  delete data from the table: "team"
  """
  delete_team(
    """
    filter the rows which have to be deleted
    """
    where: team_bool_exp!
  ): team_mutation_response

  """
  delete single row from the table: "team"
  """
  delete_team_by_pk(id: uuid!): team

  """
  delete data from the table: "team_invitation"
  """
  delete_team_invitation(
    """
    filter the rows which have to be deleted
    """
    where: team_invitation_bool_exp!
  ): team_invitation_mutation_response

  """
  delete single row from the table: "team_invitation"
  """
  delete_team_invitation_by_pk(id: uuid!): team_invitation

  """
  delete data from the table: "team_member"
  """
  delete_team_member(
    """
    filter the rows which have to be deleted
    """
    where: team_member_bool_exp!
  ): team_member_mutation_response

  """
  delete single row from the table: "team_member"
  """
  delete_team_member_by_pk(team_id: uuid!, user_id: uuid!): team_member

  """
  delete data from the table: "topic"
  """
  delete_topic(
    """
    filter the rows which have to be deleted
    """
    where: topic_bool_exp!
  ): topic_mutation_response

  """
  delete single row from the table: "topic"
  """
  delete_topic_by_pk(id: uuid!): topic

  """
  delete data from the table: "topic_member"
  """
  delete_topic_member(
    """
    filter the rows which have to be deleted
    """
    where: topic_member_bool_exp!
  ): topic_member_mutation_response

  """
  delete single row from the table: "topic_member"
  """
  delete_topic_member_by_pk(topic_id: uuid!, user_id: uuid!): topic_member

  """
  delete data from the table: "transcription"
  """
  delete_transcription(
    """
    filter the rows which have to be deleted
    """
    where: transcription_bool_exp!
  ): transcription_mutation_response

  """
  delete single row from the table: "transcription"
  """
  delete_transcription_by_pk(id: uuid!): transcription

  """
  delete data from the table: "transcription_status"
  """
  delete_transcription_status(
    """
    filter the rows which have to be deleted
    """
    where: transcription_status_bool_exp!
  ): transcription_status_mutation_response

  """
  delete single row from the table: "transcription_status"
  """
  delete_transcription_status_by_pk(value: String!): transcription_status

  """
  delete data from the table: "user"
  """
  delete_user(
    """
    filter the rows which have to be deleted
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: uuid!): user

  """
  delete data from the table: "whitelist"
  """
  delete_whitelist(
    """
    filter the rows which have to be deleted
    """
    where: whitelist_bool_exp!
  ): whitelist_mutation_response

  """
  delete single row from the table: "whitelist"
  """
  delete_whitelist_by_pk(email: String!): whitelist

  """
  insert data into the table: "account"
  """
  insert_account(
    """
    the rows to be inserted
    """
    objects: [account_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: account_on_conflict
  ): account_mutation_response

  """
  insert a single row into the table: "account"
  """
  insert_account_one(
    """
    the row to be inserted
    """
    object: account_insert_input!

    """
    on conflict condition
    """
    on_conflict: account_on_conflict
  ): account

  """
  insert data into the table: "attachment"
  """
  insert_attachment(
    """
    the rows to be inserted
    """
    objects: [attachment_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: attachment_on_conflict
  ): attachment_mutation_response

  """
  insert a single row into the table: "attachment"
  """
  insert_attachment_one(
    """
    the row to be inserted
    """
    object: attachment_insert_input!

    """
    on conflict condition
    """
    on_conflict: attachment_on_conflict
  ): attachment

  """
  insert data into the table: "last_seen_message"
  """
  insert_last_seen_message(
    """
    the rows to be inserted
    """
    objects: [last_seen_message_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: last_seen_message_on_conflict
  ): last_seen_message_mutation_response

  """
  insert a single row into the table: "last_seen_message"
  """
  insert_last_seen_message_one(
    """
    the row to be inserted
    """
    object: last_seen_message_insert_input!

    """
    on conflict condition
    """
    on_conflict: last_seen_message_on_conflict
  ): last_seen_message

  """
  insert data into the table: "membership_status"
  """
  insert_membership_status(
    """
    the rows to be inserted
    """
    objects: [membership_status_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: membership_status_on_conflict
  ): membership_status_mutation_response

  """
  insert a single row into the table: "membership_status"
  """
  insert_membership_status_one(
    """
    the row to be inserted
    """
    object: membership_status_insert_input!

    """
    on conflict condition
    """
    on_conflict: membership_status_on_conflict
  ): membership_status

  """
  insert data into the table: "message"
  """
  insert_message(
    """
    the rows to be inserted
    """
    objects: [message_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: message_on_conflict
  ): message_mutation_response

  """
  insert a single row into the table: "message"
  """
  insert_message_one(
    """
    the row to be inserted
    """
    object: message_insert_input!

    """
    on conflict condition
    """
    on_conflict: message_on_conflict
  ): message

  """
  insert data into the table: "message_reaction"
  """
  insert_message_reaction(
    """
    the rows to be inserted
    """
    objects: [message_reaction_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: message_reaction_on_conflict
  ): message_reaction_mutation_response

  """
  insert a single row into the table: "message_reaction"
  """
  insert_message_reaction_one(
    """
    the row to be inserted
    """
    object: message_reaction_insert_input!

    """
    on conflict condition
    """
    on_conflict: message_reaction_on_conflict
  ): message_reaction

  """
  insert data into the table: "message_type"
  """
  insert_message_type(
    """
    the rows to be inserted
    """
    objects: [message_type_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: message_type_on_conflict
  ): message_type_mutation_response

  """
  insert a single row into the table: "message_type"
  """
  insert_message_type_one(
    """
    the row to be inserted
    """
    object: message_type_insert_input!

    """
    on conflict condition
    """
    on_conflict: message_type_on_conflict
  ): message_type

  """
  insert data into the table: "notification"
  """
  insert_notification(
    """
    the rows to be inserted
    """
    objects: [notification_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: notification_on_conflict
  ): notification_mutation_response

  """
  insert a single row into the table: "notification"
  """
  insert_notification_one(
    """
    the row to be inserted
    """
    object: notification_insert_input!

    """
    on conflict condition
    """
    on_conflict: notification_on_conflict
  ): notification

  """
  insert data into the table: "room"
  """
  insert_room(
    """
    the rows to be inserted
    """
    objects: [room_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: room_on_conflict
  ): room_mutation_response

  """
  insert data into the table: "room_invitation"
  """
  insert_room_invitation(
    """
    the rows to be inserted
    """
    objects: [room_invitation_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: room_invitation_on_conflict
  ): room_invitation_mutation_response

  """
  insert a single row into the table: "room_invitation"
  """
  insert_room_invitation_one(
    """
    the row to be inserted
    """
    object: room_invitation_insert_input!

    """
    on conflict condition
    """
    on_conflict: room_invitation_on_conflict
  ): room_invitation

  """
  insert data into the table: "room_member"
  """
  insert_room_member(
    """
    the rows to be inserted
    """
    objects: [room_member_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: room_member_on_conflict
  ): room_member_mutation_response

  """
  insert a single row into the table: "room_member"
  """
  insert_room_member_one(
    """
    the row to be inserted
    """
    object: room_member_insert_input!

    """
    on conflict condition
    """
    on_conflict: room_member_on_conflict
  ): room_member

  """
  insert a single row into the table: "room"
  """
  insert_room_one(
    """
    the row to be inserted
    """
    object: room_insert_input!

    """
    on conflict condition
    """
    on_conflict: room_on_conflict
  ): room

  """
  insert data into the table: "space"
  """
  insert_space(
    """
    the rows to be inserted
    """
    objects: [space_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: space_on_conflict
  ): space_mutation_response

  """
  insert data into the table: "space_member"
  """
  insert_space_member(
    """
    the rows to be inserted
    """
    objects: [space_member_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: space_member_on_conflict
  ): space_member_mutation_response

  """
  insert a single row into the table: "space_member"
  """
  insert_space_member_one(
    """
    the row to be inserted
    """
    object: space_member_insert_input!

    """
    on conflict condition
    """
    on_conflict: space_member_on_conflict
  ): space_member

  """
  insert a single row into the table: "space"
  """
  insert_space_one(
    """
    the row to be inserted
    """
    object: space_insert_input!

    """
    on conflict condition
    """
    on_conflict: space_on_conflict
  ): space

  """
  insert data into the table: "team"
  """
  insert_team(
    """
    the rows to be inserted
    """
    objects: [team_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: team_on_conflict
  ): team_mutation_response

  """
  insert data into the table: "team_invitation"
  """
  insert_team_invitation(
    """
    the rows to be inserted
    """
    objects: [team_invitation_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: team_invitation_on_conflict
  ): team_invitation_mutation_response

  """
  insert a single row into the table: "team_invitation"
  """
  insert_team_invitation_one(
    """
    the row to be inserted
    """
    object: team_invitation_insert_input!

    """
    on conflict condition
    """
    on_conflict: team_invitation_on_conflict
  ): team_invitation

  """
  insert data into the table: "team_member"
  """
  insert_team_member(
    """
    the rows to be inserted
    """
    objects: [team_member_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: team_member_on_conflict
  ): team_member_mutation_response

  """
  insert a single row into the table: "team_member"
  """
  insert_team_member_one(
    """
    the row to be inserted
    """
    object: team_member_insert_input!

    """
    on conflict condition
    """
    on_conflict: team_member_on_conflict
  ): team_member

  """
  insert a single row into the table: "team"
  """
  insert_team_one(
    """
    the row to be inserted
    """
    object: team_insert_input!

    """
    on conflict condition
    """
    on_conflict: team_on_conflict
  ): team

  """
  insert data into the table: "topic"
  """
  insert_topic(
    """
    the rows to be inserted
    """
    objects: [topic_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: topic_on_conflict
  ): topic_mutation_response

  """
  insert data into the table: "topic_member"
  """
  insert_topic_member(
    """
    the rows to be inserted
    """
    objects: [topic_member_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: topic_member_on_conflict
  ): topic_member_mutation_response

  """
  insert a single row into the table: "topic_member"
  """
  insert_topic_member_one(
    """
    the row to be inserted
    """
    object: topic_member_insert_input!

    """
    on conflict condition
    """
    on_conflict: topic_member_on_conflict
  ): topic_member

  """
  insert a single row into the table: "topic"
  """
  insert_topic_one(
    """
    the row to be inserted
    """
    object: topic_insert_input!

    """
    on conflict condition
    """
    on_conflict: topic_on_conflict
  ): topic

  """
  insert data into the table: "transcription"
  """
  insert_transcription(
    """
    the rows to be inserted
    """
    objects: [transcription_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: transcription_on_conflict
  ): transcription_mutation_response

  """
  insert a single row into the table: "transcription"
  """
  insert_transcription_one(
    """
    the row to be inserted
    """
    object: transcription_insert_input!

    """
    on conflict condition
    """
    on_conflict: transcription_on_conflict
  ): transcription

  """
  insert data into the table: "transcription_status"
  """
  insert_transcription_status(
    """
    the rows to be inserted
    """
    objects: [transcription_status_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: transcription_status_on_conflict
  ): transcription_status_mutation_response

  """
  insert a single row into the table: "transcription_status"
  """
  insert_transcription_status_one(
    """
    the row to be inserted
    """
    object: transcription_status_insert_input!

    """
    on conflict condition
    """
    on_conflict: transcription_status_on_conflict
  ): transcription_status

  """
  insert data into the table: "user"
  """
  insert_user(
    """
    the rows to be inserted
    """
    objects: [user_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """
    the row to be inserted
    """
    object: user_insert_input!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "whitelist"
  """
  insert_whitelist(
    """
    the rows to be inserted
    """
    objects: [whitelist_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: whitelist_on_conflict
  ): whitelist_mutation_response

  """
  insert a single row into the table: "whitelist"
  """
  insert_whitelist_one(
    """
    the row to be inserted
    """
    object: whitelist_insert_input!

    """
    on conflict condition
    """
    on_conflict: whitelist_on_conflict
  ): whitelist

  """
  update data of the table: "account"
  """
  update_account(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: account_set_input

    """
    filter the rows which have to be updated
    """
    where: account_bool_exp!
  ): account_mutation_response

  """
  update single row of the table: "account"
  """
  update_account_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: account_set_input
    pk_columns: account_pk_columns_input!
  ): account

  """
  update data of the table: "attachment"
  """
  update_attachment(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: attachment_set_input

    """
    filter the rows which have to be updated
    """
    where: attachment_bool_exp!
  ): attachment_mutation_response

  """
  update single row of the table: "attachment"
  """
  update_attachment_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: attachment_set_input
    pk_columns: attachment_pk_columns_input!
  ): attachment

  """
  update data of the table: "last_seen_message"
  """
  update_last_seen_message(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: last_seen_message_set_input

    """
    filter the rows which have to be updated
    """
    where: last_seen_message_bool_exp!
  ): last_seen_message_mutation_response

  """
  update single row of the table: "last_seen_message"
  """
  update_last_seen_message_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: last_seen_message_set_input
    pk_columns: last_seen_message_pk_columns_input!
  ): last_seen_message

  """
  update data of the table: "membership_status"
  """
  update_membership_status(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: membership_status_set_input

    """
    filter the rows which have to be updated
    """
    where: membership_status_bool_exp!
  ): membership_status_mutation_response

  """
  update single row of the table: "membership_status"
  """
  update_membership_status_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: membership_status_set_input
    pk_columns: membership_status_pk_columns_input!
  ): membership_status

  """
  update data of the table: "message"
  """
  update_message(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: message_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: message_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_set_input

    """
    filter the rows which have to be updated
    """
    where: message_bool_exp!
  ): message_mutation_response

  """
  update single row of the table: "message"
  """
  update_message_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: message_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: message_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: message_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: message_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: message_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  """
  update data of the table: "message_reaction"
  """
  update_message_reaction(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_reaction_set_input

    """
    filter the rows which have to be updated
    """
    where: message_reaction_bool_exp!
  ): message_reaction_mutation_response

  """
  update single row of the table: "message_reaction"
  """
  update_message_reaction_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_reaction_set_input
    pk_columns: message_reaction_pk_columns_input!
  ): message_reaction

  """
  update data of the table: "message_type"
  """
  update_message_type(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_type_set_input

    """
    filter the rows which have to be updated
    """
    where: message_type_bool_exp!
  ): message_type_mutation_response

  """
  update single row of the table: "message_type"
  """
  update_message_type_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: message_type_set_input
    pk_columns: message_type_pk_columns_input!
  ): message_type

  """
  update data of the table: "notification"
  """
  update_notification(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: notification_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notification_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notification_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notification_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: notification_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: notification_set_input

    """
    filter the rows which have to be updated
    """
    where: notification_bool_exp!
  ): notification_mutation_response

  """
  update single row of the table: "notification"
  """
  update_notification_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: notification_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notification_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notification_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notification_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: notification_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: notification_set_input
    pk_columns: notification_pk_columns_input!
  ): notification

  """
  update data of the table: "room"
  """
  update_room(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: room_set_input

    """
    filter the rows which have to be updated
    """
    where: room_bool_exp!
  ): room_mutation_response

  """
  update single row of the table: "room"
  """
  update_room_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: room_set_input
    pk_columns: room_pk_columns_input!
  ): room

  """
  update data of the table: "room_invitation"
  """
  update_room_invitation(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: room_invitation_set_input

    """
    filter the rows which have to be updated
    """
    where: room_invitation_bool_exp!
  ): room_invitation_mutation_response

  """
  update single row of the table: "room_invitation"
  """
  update_room_invitation_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: room_invitation_set_input
    pk_columns: room_invitation_pk_columns_input!
  ): room_invitation

  """
  update data of the table: "room_member"
  """
  update_room_member(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: room_member_set_input

    """
    filter the rows which have to be updated
    """
    where: room_member_bool_exp!
  ): room_member_mutation_response

  """
  update single row of the table: "room_member"
  """
  update_room_member_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: room_member_set_input
    pk_columns: room_member_pk_columns_input!
  ): room_member

  """
  update data of the table: "space"
  """
  update_space(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: space_set_input

    """
    filter the rows which have to be updated
    """
    where: space_bool_exp!
  ): space_mutation_response

  """
  update single row of the table: "space"
  """
  update_space_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: space_set_input
    pk_columns: space_pk_columns_input!
  ): space

  """
  update data of the table: "space_member"
  """
  update_space_member(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: space_member_set_input

    """
    filter the rows which have to be updated
    """
    where: space_member_bool_exp!
  ): space_member_mutation_response

  """
  update single row of the table: "space_member"
  """
  update_space_member_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: space_member_set_input
    pk_columns: space_member_pk_columns_input!
  ): space_member

  """
  update data of the table: "team"
  """
  update_team(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: team_set_input

    """
    filter the rows which have to be updated
    """
    where: team_bool_exp!
  ): team_mutation_response

  """
  update single row of the table: "team"
  """
  update_team_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: team_set_input
    pk_columns: team_pk_columns_input!
  ): team

  """
  update data of the table: "team_invitation"
  """
  update_team_invitation(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: team_invitation_set_input

    """
    filter the rows which have to be updated
    """
    where: team_invitation_bool_exp!
  ): team_invitation_mutation_response

  """
  update single row of the table: "team_invitation"
  """
  update_team_invitation_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: team_invitation_set_input
    pk_columns: team_invitation_pk_columns_input!
  ): team_invitation

  """
  update data of the table: "team_member"
  """
  update_team_member(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: team_member_set_input

    """
    filter the rows which have to be updated
    """
    where: team_member_bool_exp!
  ): team_member_mutation_response

  """
  update single row of the table: "team_member"
  """
  update_team_member_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: team_member_set_input
    pk_columns: team_member_pk_columns_input!
  ): team_member

  """
  update data of the table: "topic"
  """
  update_topic(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: topic_set_input

    """
    filter the rows which have to be updated
    """
    where: topic_bool_exp!
  ): topic_mutation_response

  """
  update single row of the table: "topic"
  """
  update_topic_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: topic_set_input
    pk_columns: topic_pk_columns_input!
  ): topic

  """
  update data of the table: "topic_member"
  """
  update_topic_member(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: topic_member_set_input

    """
    filter the rows which have to be updated
    """
    where: topic_member_bool_exp!
  ): topic_member_mutation_response

  """
  update single row of the table: "topic_member"
  """
  update_topic_member_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: topic_member_set_input
    pk_columns: topic_member_pk_columns_input!
  ): topic_member

  """
  update data of the table: "transcription"
  """
  update_transcription(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: transcription_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transcription_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transcription_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transcription_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: transcription_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: transcription_set_input

    """
    filter the rows which have to be updated
    """
    where: transcription_bool_exp!
  ): transcription_mutation_response

  """
  update single row of the table: "transcription"
  """
  update_transcription_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: transcription_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: transcription_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: transcription_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: transcription_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: transcription_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: transcription_set_input
    pk_columns: transcription_pk_columns_input!
  ): transcription

  """
  update data of the table: "transcription_status"
  """
  update_transcription_status(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: transcription_status_set_input

    """
    filter the rows which have to be updated
    """
    where: transcription_status_bool_exp!
  ): transcription_status_mutation_response

  """
  update single row of the table: "transcription_status"
  """
  update_transcription_status_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: transcription_status_set_input
    pk_columns: transcription_status_pk_columns_input!
  ): transcription_status

  """
  update data of the table: "user"
  """
  update_user(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input

    """
    filter the rows which have to be updated
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update data of the table: "whitelist"
  """
  update_whitelist(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: whitelist_set_input

    """
    filter the rows which have to be updated
    """
    where: whitelist_bool_exp!
  ): whitelist_mutation_response

  """
  update single row of the table: "whitelist"
  """
  update_whitelist_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: whitelist_set_input
    pk_columns: whitelist_pk_columns_input!
  ): whitelist

  """
  perform the action: "upgrade_current_user"
  """
  upgrade_current_user: UpgradeUserResponse
}

"""
columns and relationships of "notification"
"""
type notification {
  created_at: timestamptz!
  data(
    """
    JSON select path
    """
    path: String
  ): jsonb!
  id: uuid!
  read_at: timestamptz
  updated_at: timestamptz!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "notification"
"""
type notification_aggregate {
  aggregate: notification_aggregate_fields
  nodes: [notification!]!
}

"""
aggregate fields of "notification"
"""
type notification_aggregate_fields {
  count(columns: [notification_select_column!], distinct: Boolean): Int
  max: notification_max_fields
  min: notification_min_fields
}

"""
order by aggregate values of table "notification"
"""
input notification_aggregate_order_by {
  count: order_by
  max: notification_max_order_by
  min: notification_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input notification_append_input {
  data: jsonb
}

"""
input type for inserting array relation for remote table "notification"
"""
input notification_arr_rel_insert_input {
  data: [notification_insert_input!]!
  on_conflict: notification_on_conflict
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input notification_bool_exp {
  _and: [notification_bool_exp]
  _not: notification_bool_exp
  _or: [notification_bool_exp]
  created_at: timestamptz_comparison_exp
  data: jsonb_comparison_exp
  id: uuid_comparison_exp
  read_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notification"
"""
enum notification_constraint {
  """
  unique or primary key constraint
  """
  notification_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notification_delete_at_path_input {
  data: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notification_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notification_delete_key_input {
  data: String
}

"""
input type for inserting data into table "notification"
"""
input notification_insert_input {
  created_at: timestamptz
  data: jsonb
  id: uuid
  read_at: timestamptz
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type notification_max_fields {
  created_at: timestamptz
  id: uuid
  read_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "notification"
"""
input notification_max_order_by {
  created_at: order_by
  id: order_by
  read_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type notification_min_fields {
  created_at: timestamptz
  id: uuid
  read_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "notification"
"""
input notification_min_order_by {
  created_at: order_by
  id: order_by
  read_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "notification"
"""
type notification_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [notification!]!
}

"""
input type for inserting object relation for remote table "notification"
"""
input notification_obj_rel_insert_input {
  data: notification_insert_input!
  on_conflict: notification_on_conflict
}

"""
on conflict condition type for table "notification"
"""
input notification_on_conflict {
  constraint: notification_constraint!
  update_columns: [notification_update_column!]!
  where: notification_bool_exp
}

"""
ordering options when selecting data from "notification"
"""
input notification_order_by {
  created_at: order_by
  data: order_by
  id: order_by
  read_at: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "notification"
"""
input notification_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input notification_prepend_input {
  data: jsonb
}

"""
select columns of table "notification"
"""
enum notification_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  data

  """
  column name
  """
  id

  """
  column name
  """
  read_at

  """
  column name
  """
  updated_at

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "notification"
"""
input notification_set_input {
  created_at: timestamptz
  data: jsonb
  id: uuid
  read_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "notification"
"""
enum notification_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  data

  """
  column name
  """
  id

  """
  column name
  """
  read_at

  """
  column name
  """
  updated_at

  """
  column name
  """
  user_id
}

"""
column ordering options
"""
enum order_by {
  """
  in the ascending order, nulls last
  """
  asc

  """
  in the ascending order, nulls first
  """
  asc_nulls_first

  """
  in the ascending order, nulls last
  """
  asc_nulls_last

  """
  in the descending order, nulls first
  """
  desc

  """
  in the descending order, nulls first
  """
  desc_nulls_first

  """
  in the descending order, nulls last
  """
  desc_nulls_last
}

"""
query root
"""
type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """
    distinct select on columns
    """
    distinct_on: [account_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [account_order_by!]

    """
    filter the rows returned
    """
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [account_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [account_order_by!]

    """
    filter the rows returned
    """
    where: account_bool_exp
  ): account_aggregate!

  """
  fetch data from the table: "account" using primary key columns
  """
  account_by_pk(id: uuid!): account

  """
  fetch data from the table: "attachment"
  """
  attachment(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): [attachment!]!

  """
  fetch aggregated fields from the table: "attachment"
  """
  attachment_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): attachment_aggregate!

  """
  fetch data from the table: "attachment" using primary key columns
  """
  attachment_by_pk(id: uuid!): attachment

  """
  perform the action: "get_download_url"
  """
  get_download_url(uuid: uuid!): DownloadUrlResponse

  """
  perform the action: "get_upload_url"
  """
  get_upload_url(fileName: String!, mimeType: String!): UploadUrlResponse

  """
  fetch data from the table: "last_seen_message"
  """
  last_seen_message(
    """
    distinct select on columns
    """
    distinct_on: [last_seen_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [last_seen_message_order_by!]

    """
    filter the rows returned
    """
    where: last_seen_message_bool_exp
  ): [last_seen_message!]!

  """
  fetch aggregated fields from the table: "last_seen_message"
  """
  last_seen_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [last_seen_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [last_seen_message_order_by!]

    """
    filter the rows returned
    """
    where: last_seen_message_bool_exp
  ): last_seen_message_aggregate!

  """
  fetch data from the table: "last_seen_message" using primary key columns
  """
  last_seen_message_by_pk(topic_id: uuid!, user_id: uuid!): last_seen_message

  """
  perform the action: "lookup_team_name"
  """
  lookup_team_name(token: String!): LookupTeamNameResponse

  """
  fetch data from the table: "membership_status"
  """
  membership_status(
    """
    distinct select on columns
    """
    distinct_on: [membership_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [membership_status_order_by!]

    """
    filter the rows returned
    """
    where: membership_status_bool_exp
  ): [membership_status!]!

  """
  fetch aggregated fields from the table: "membership_status"
  """
  membership_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [membership_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [membership_status_order_by!]

    """
    filter the rows returned
    """
    where: membership_status_bool_exp
  ): membership_status_aggregate!

  """
  fetch data from the table: "membership_status" using primary key columns
  """
  membership_status_by_pk(value: String!): membership_status

  """
  fetch data from the table: "message"
  """
  message(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "message" using primary key columns
  """
  message_by_pk(id: uuid!): message

  """
  fetch data from the table: "message_reaction"
  """
  message_reaction(
    """
    distinct select on columns
    """
    distinct_on: [message_reaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_reaction_order_by!]

    """
    filter the rows returned
    """
    where: message_reaction_bool_exp
  ): [message_reaction!]!

  """
  fetch aggregated fields from the table: "message_reaction"
  """
  message_reaction_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_reaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_reaction_order_by!]

    """
    filter the rows returned
    """
    where: message_reaction_bool_exp
  ): message_reaction_aggregate!

  """
  fetch data from the table: "message_reaction" using primary key columns
  """
  message_reaction_by_pk(emoji: String!, message_id: uuid!, user_id: uuid!): message_reaction

  """
  fetch data from the table: "message_type"
  """
  message_type(
    """
    distinct select on columns
    """
    distinct_on: [message_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_type_order_by!]

    """
    filter the rows returned
    """
    where: message_type_bool_exp
  ): [message_type!]!

  """
  fetch aggregated fields from the table: "message_type"
  """
  message_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_type_order_by!]

    """
    filter the rows returned
    """
    where: message_type_bool_exp
  ): message_type_aggregate!

  """
  fetch data from the table: "message_type" using primary key columns
  """
  message_type_by_pk(value: String!): message_type

  """
  fetch data from the table: "notification"
  """
  notification(
    """
    distinct select on columns
    """
    distinct_on: [notification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [notification_order_by!]

    """
    filter the rows returned
    """
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [notification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [notification_order_by!]

    """
    filter the rows returned
    """
    where: notification_bool_exp
  ): notification_aggregate!

  """
  fetch data from the table: "notification" using primary key columns
  """
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "room"
  """
  room(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): [room!]!

  """
  fetch aggregated fields from the table: "room"
  """
  room_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): room_aggregate!

  """
  fetch data from the table: "room" using primary key columns
  """
  room_by_pk(id: uuid!): room

  """
  fetch data from the table: "room_invitation"
  """
  room_invitation(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): [room_invitation!]!

  """
  fetch aggregated fields from the table: "room_invitation"
  """
  room_invitation_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): room_invitation_aggregate!

  """
  fetch data from the table: "room_invitation" using primary key columns
  """
  room_invitation_by_pk(id: uuid!): room_invitation

  """
  perform the action: "room_invitation_view"
  """
  room_invitation_view(token: String!): RoomInvitationViewResponse

  """
  fetch data from the table: "room_last_posted_message"
  """
  room_last_posted_message(
    """
    distinct select on columns
    """
    distinct_on: [room_last_posted_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_last_posted_message_order_by!]

    """
    filter the rows returned
    """
    where: room_last_posted_message_bool_exp
  ): [room_last_posted_message!]!

  """
  fetch aggregated fields from the table: "room_last_posted_message"
  """
  room_last_posted_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_last_posted_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_last_posted_message_order_by!]

    """
    filter the rows returned
    """
    where: room_last_posted_message_bool_exp
  ): room_last_posted_message_aggregate!

  """
  fetch data from the table: "room_member"
  """
  room_member(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): [room_member!]!

  """
  fetch aggregated fields from the table: "room_member"
  """
  room_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): room_member_aggregate!

  """
  fetch data from the table: "room_member" using primary key columns
  """
  room_member_by_pk(room_id: uuid!, user_id: uuid!): room_member

  """
  fetch data from the table: "space"
  """
  space(
    """
    distinct select on columns
    """
    distinct_on: [space_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_order_by!]

    """
    filter the rows returned
    """
    where: space_bool_exp
  ): [space!]!

  """
  fetch aggregated fields from the table: "space"
  """
  space_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_order_by!]

    """
    filter the rows returned
    """
    where: space_bool_exp
  ): space_aggregate!

  """
  fetch data from the table: "space" using primary key columns
  """
  space_by_pk(id: uuid!): space

  """
  fetch data from the table: "space_member"
  """
  space_member(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): [space_member!]!

  """
  fetch aggregated fields from the table: "space_member"
  """
  space_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): space_member_aggregate!

  """
  fetch data from the table: "space_member" using primary key columns
  """
  space_member_by_pk(space_id: uuid!, user_id: uuid!): space_member

  """
  fetch data from the table: "team"
  """
  team(
    """
    distinct select on columns
    """
    distinct_on: [team_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_order_by!]

    """
    filter the rows returned
    """
    where: team_bool_exp
  ): [team!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_order_by!]

    """
    filter the rows returned
    """
    where: team_bool_exp
  ): team_aggregate!

  """
  fetch data from the table: "team" using primary key columns
  """
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "team_invitation"
  """
  team_invitation(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): [team_invitation!]!

  """
  fetch aggregated fields from the table: "team_invitation"
  """
  team_invitation_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): team_invitation_aggregate!

  """
  fetch data from the table: "team_invitation" using primary key columns
  """
  team_invitation_by_pk(id: uuid!): team_invitation

  """
  fetch data from the table: "team_member"
  """
  team_member(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): [team_member!]!

  """
  fetch aggregated fields from the table: "team_member"
  """
  team_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): team_member_aggregate!

  """
  fetch data from the table: "team_member" using primary key columns
  """
  team_member_by_pk(team_id: uuid!, user_id: uuid!): team_member

  """
  fetch data from the table: "topic"
  """
  topic(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  fetch aggregated fields from the table: "topic"
  """
  topic_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!

  """
  fetch data from the table: "topic" using primary key columns
  """
  topic_by_pk(id: uuid!): topic

  """
  fetch data from the table: "topic_member"
  """
  topic_member(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): [topic_member!]!

  """
  fetch aggregated fields from the table: "topic_member"
  """
  topic_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): topic_member_aggregate!

  """
  fetch data from the table: "topic_member" using primary key columns
  """
  topic_member_by_pk(topic_id: uuid!, user_id: uuid!): topic_member

  """
  fetch data from the table: "transcription"
  """
  transcription(
    """
    distinct select on columns
    """
    distinct_on: [transcription_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_order_by!]

    """
    filter the rows returned
    """
    where: transcription_bool_exp
  ): [transcription!]!

  """
  fetch aggregated fields from the table: "transcription"
  """
  transcription_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [transcription_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_order_by!]

    """
    filter the rows returned
    """
    where: transcription_bool_exp
  ): transcription_aggregate!

  """
  fetch data from the table: "transcription" using primary key columns
  """
  transcription_by_pk(id: uuid!): transcription

  """
  fetch data from the table: "transcription_status"
  """
  transcription_status(
    """
    distinct select on columns
    """
    distinct_on: [transcription_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_status_order_by!]

    """
    filter the rows returned
    """
    where: transcription_status_bool_exp
  ): [transcription_status!]!

  """
  fetch aggregated fields from the table: "transcription_status"
  """
  transcription_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [transcription_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_status_order_by!]

    """
    filter the rows returned
    """
    where: transcription_status_bool_exp
  ): transcription_status_aggregate!

  """
  fetch data from the table: "transcription_status" using primary key columns
  """
  transcription_status_by_pk(value: String!): transcription_status

  """
  fetch data from the table: "unread_messages"
  """
  unread_messages(
    """
    distinct select on columns
    """
    distinct_on: [unread_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [unread_messages_order_by!]

    """
    filter the rows returned
    """
    where: unread_messages_bool_exp
  ): [unread_messages!]!

  """
  fetch aggregated fields from the table: "unread_messages"
  """
  unread_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [unread_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [unread_messages_order_by!]

    """
    filter the rows returned
    """
    where: unread_messages_bool_exp
  ): unread_messages_aggregate!

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: uuid!): user

  """
  fetch data from the table: "whitelist"
  """
  whitelist(
    """
    distinct select on columns
    """
    distinct_on: [whitelist_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [whitelist_order_by!]

    """
    filter the rows returned
    """
    where: whitelist_bool_exp
  ): [whitelist!]!

  """
  fetch aggregated fields from the table: "whitelist"
  """
  whitelist_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [whitelist_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [whitelist_order_by!]

    """
    filter the rows returned
    """
    where: whitelist_bool_exp
  ): whitelist_aggregate!

  """
  fetch data from the table: "whitelist" using primary key columns
  """
  whitelist_by_pk(email: String!): whitelist
}

"""
columns and relationships of "room"
"""
type room {
  created_at: timestamptz!

  """
  An object relationship
  """
  creator: user!
  creator_id: uuid!
  deadline: timestamptz!
  finished_at: timestamptz
  id: uuid!

  """
  An array relationship
  """
  invitations(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): [room_invitation!]!

  """
  An aggregated array relationship
  """
  invitations_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): room_invitation_aggregate!
  is_private: Boolean!
  last_activity_at: timestamptz

  """
  An object relationship
  """
  last_posted_message: room_last_posted_message

  """
  An array relationship
  """
  members(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): [room_member!]!

  """
  An aggregated array relationship
  """
  members_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): room_member_aggregate!
  name: String!
  notification_job_id: String
  slug: String!
  source_google_calendar_event_id: String

  """
  An object relationship
  """
  space: space!
  space_id: uuid!
  summary: String

  """
  An array relationship
  """
  topics(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  An aggregated array relationship
  """
  topics_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!
}

"""
aggregated selection of "room"
"""
type room_aggregate {
  aggregate: room_aggregate_fields
  nodes: [room!]!
}

"""
aggregate fields of "room"
"""
type room_aggregate_fields {
  count(columns: [room_select_column!], distinct: Boolean): Int
  max: room_max_fields
  min: room_min_fields
}

"""
order by aggregate values of table "room"
"""
input room_aggregate_order_by {
  count: order_by
  max: room_max_order_by
  min: room_min_order_by
}

"""
input type for inserting array relation for remote table "room"
"""
input room_arr_rel_insert_input {
  data: [room_insert_input!]!
  on_conflict: room_on_conflict
}

"""
Boolean expression to filter rows from the table "room". All fields are combined with a logical 'AND'.
"""
input room_bool_exp {
  _and: [room_bool_exp]
  _not: room_bool_exp
  _or: [room_bool_exp]
  created_at: timestamptz_comparison_exp
  creator: user_bool_exp
  creator_id: uuid_comparison_exp
  deadline: timestamptz_comparison_exp
  finished_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  invitations: room_invitation_bool_exp
  is_private: Boolean_comparison_exp
  last_activity_at: timestamptz_comparison_exp
  last_posted_message: room_last_posted_message_bool_exp
  members: room_member_bool_exp
  name: String_comparison_exp
  notification_job_id: String_comparison_exp
  slug: String_comparison_exp
  source_google_calendar_event_id: String_comparison_exp
  space: space_bool_exp
  space_id: uuid_comparison_exp
  summary: String_comparison_exp
  topics: topic_bool_exp
}

"""
unique or primary key constraints on table "room"
"""
enum room_constraint {
  """
  unique or primary key constraint
  """
  room_pkey

  """
  unique or primary key constraint
  """
  room_slug_space_id_key
}

"""
input type for inserting data into table "room"
"""
input room_insert_input {
  created_at: timestamptz
  creator: user_obj_rel_insert_input
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  invitations: room_invitation_arr_rel_insert_input
  is_private: Boolean
  last_activity_at: timestamptz
  members: room_member_arr_rel_insert_input
  name: String
  notification_job_id: String
  slug: String
  source_google_calendar_event_id: String
  space: space_obj_rel_insert_input
  space_id: uuid
  summary: String
  topics: topic_arr_rel_insert_input
}

"""
columns and relationships of "room_invitation"
"""
type room_invitation {
  created_at: timestamptz!
  email: String!
  id: uuid!

  """
  An object relationship
  """
  inviting_user: user!
  inviting_user_id: uuid!

  """
  An object relationship
  """
  room: room!
  room_id: uuid!

  """
  An object relationship
  """
  team: team!
  team_id: uuid!
  token: uuid!
  used_at: date

  """
  An object relationship
  """
  used_by_user: user
  used_by_user_id: uuid
}

"""
aggregated selection of "room_invitation"
"""
type room_invitation_aggregate {
  aggregate: room_invitation_aggregate_fields
  nodes: [room_invitation!]!
}

"""
aggregate fields of "room_invitation"
"""
type room_invitation_aggregate_fields {
  count(columns: [room_invitation_select_column!], distinct: Boolean): Int
  max: room_invitation_max_fields
  min: room_invitation_min_fields
}

"""
order by aggregate values of table "room_invitation"
"""
input room_invitation_aggregate_order_by {
  count: order_by
  max: room_invitation_max_order_by
  min: room_invitation_min_order_by
}

"""
input type for inserting array relation for remote table "room_invitation"
"""
input room_invitation_arr_rel_insert_input {
  data: [room_invitation_insert_input!]!
  on_conflict: room_invitation_on_conflict
}

"""
Boolean expression to filter rows from the table "room_invitation". All fields are combined with a logical 'AND'.
"""
input room_invitation_bool_exp {
  _and: [room_invitation_bool_exp]
  _not: room_invitation_bool_exp
  _or: [room_invitation_bool_exp]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  inviting_user: user_bool_exp
  inviting_user_id: uuid_comparison_exp
  room: room_bool_exp
  room_id: uuid_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  token: uuid_comparison_exp
  used_at: date_comparison_exp
  used_by_user: user_bool_exp
  used_by_user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "room_invitation"
"""
enum room_invitation_constraint {
  """
  unique or primary key constraint
  """
  room_invitation_pkey

  """
  unique or primary key constraint
  """
  room_invitation_token_key
}

"""
input type for inserting data into table "room_invitation"
"""
input room_invitation_insert_input {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user: user_obj_rel_insert_input
  inviting_user_id: uuid
  room: room_obj_rel_insert_input
  room_id: uuid
  team: team_obj_rel_insert_input
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user: user_obj_rel_insert_input
  used_by_user_id: uuid
}

"""
aggregate max on columns
"""
type room_invitation_max_fields {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user_id: uuid
  room_id: uuid
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user_id: uuid
}

"""
order by max() on columns of table "room_invitation"
"""
input room_invitation_max_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  inviting_user_id: order_by
  room_id: order_by
  team_id: order_by
  token: order_by
  used_at: order_by
  used_by_user_id: order_by
}

"""
aggregate min on columns
"""
type room_invitation_min_fields {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user_id: uuid
  room_id: uuid
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user_id: uuid
}

"""
order by min() on columns of table "room_invitation"
"""
input room_invitation_min_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  inviting_user_id: order_by
  room_id: order_by
  team_id: order_by
  token: order_by
  used_at: order_by
  used_by_user_id: order_by
}

"""
response of any mutation on the table "room_invitation"
"""
type room_invitation_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [room_invitation!]!
}

"""
input type for inserting object relation for remote table "room_invitation"
"""
input room_invitation_obj_rel_insert_input {
  data: room_invitation_insert_input!
  on_conflict: room_invitation_on_conflict
}

"""
on conflict condition type for table "room_invitation"
"""
input room_invitation_on_conflict {
  constraint: room_invitation_constraint!
  update_columns: [room_invitation_update_column!]!
  where: room_invitation_bool_exp
}

"""
ordering options when selecting data from "room_invitation"
"""
input room_invitation_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  inviting_user: user_order_by
  inviting_user_id: order_by
  room: room_order_by
  room_id: order_by
  team: team_order_by
  team_id: order_by
  token: order_by
  used_at: order_by
  used_by_user: user_order_by
  used_by_user_id: order_by
}

"""
primary key columns input for table: "room_invitation"
"""
input room_invitation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "room_invitation"
"""
enum room_invitation_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  inviting_user_id

  """
  column name
  """
  room_id

  """
  column name
  """
  team_id

  """
  column name
  """
  token

  """
  column name
  """
  used_at

  """
  column name
  """
  used_by_user_id
}

"""
input type for updating data in table "room_invitation"
"""
input room_invitation_set_input {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user_id: uuid
  room_id: uuid
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user_id: uuid
}

"""
update columns of table "room_invitation"
"""
enum room_invitation_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  inviting_user_id

  """
  column name
  """
  room_id

  """
  column name
  """
  team_id

  """
  column name
  """
  token

  """
  column name
  """
  used_at

  """
  column name
  """
  used_by_user_id
}

"""
columns and relationships of "room_last_posted_message"
"""
type room_last_posted_message {
  last_posted_message_time: timestamptz

  """
  An object relationship
  """
  room: room
  room_id: uuid
}

"""
aggregated selection of "room_last_posted_message"
"""
type room_last_posted_message_aggregate {
  aggregate: room_last_posted_message_aggregate_fields
  nodes: [room_last_posted_message!]!
}

"""
aggregate fields of "room_last_posted_message"
"""
type room_last_posted_message_aggregate_fields {
  count(columns: [room_last_posted_message_select_column!], distinct: Boolean): Int
  max: room_last_posted_message_max_fields
  min: room_last_posted_message_min_fields
}

"""
order by aggregate values of table "room_last_posted_message"
"""
input room_last_posted_message_aggregate_order_by {
  count: order_by
  max: room_last_posted_message_max_order_by
  min: room_last_posted_message_min_order_by
}

"""
Boolean expression to filter rows from the table "room_last_posted_message". All fields are combined with a logical 'AND'.
"""
input room_last_posted_message_bool_exp {
  _and: [room_last_posted_message_bool_exp]
  _not: room_last_posted_message_bool_exp
  _or: [room_last_posted_message_bool_exp]
  last_posted_message_time: timestamptz_comparison_exp
  room: room_bool_exp
  room_id: uuid_comparison_exp
}

"""
aggregate max on columns
"""
type room_last_posted_message_max_fields {
  last_posted_message_time: timestamptz
  room_id: uuid
}

"""
order by max() on columns of table "room_last_posted_message"
"""
input room_last_posted_message_max_order_by {
  last_posted_message_time: order_by
  room_id: order_by
}

"""
aggregate min on columns
"""
type room_last_posted_message_min_fields {
  last_posted_message_time: timestamptz
  room_id: uuid
}

"""
order by min() on columns of table "room_last_posted_message"
"""
input room_last_posted_message_min_order_by {
  last_posted_message_time: order_by
  room_id: order_by
}

"""
ordering options when selecting data from "room_last_posted_message"
"""
input room_last_posted_message_order_by {
  last_posted_message_time: order_by
  room: room_order_by
  room_id: order_by
}

"""
select columns of table "room_last_posted_message"
"""
enum room_last_posted_message_select_column {
  """
  column name
  """
  last_posted_message_time

  """
  column name
  """
  room_id
}

"""
aggregate max on columns
"""
type room_max_fields {
  created_at: timestamptz
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  last_activity_at: timestamptz
  name: String
  notification_job_id: String
  slug: String
  source_google_calendar_event_id: String
  space_id: uuid
  summary: String
}

"""
order by max() on columns of table "room"
"""
input room_max_order_by {
  created_at: order_by
  creator_id: order_by
  deadline: order_by
  finished_at: order_by
  id: order_by
  last_activity_at: order_by
  name: order_by
  notification_job_id: order_by
  slug: order_by
  source_google_calendar_event_id: order_by
  space_id: order_by
  summary: order_by
}

"""
columns and relationships of "room_member"
"""
type room_member {
  """
  An object relationship
  """
  room: room!
  room_id: uuid!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "room_member"
"""
type room_member_aggregate {
  aggregate: room_member_aggregate_fields
  nodes: [room_member!]!
}

"""
aggregate fields of "room_member"
"""
type room_member_aggregate_fields {
  count(columns: [room_member_select_column!], distinct: Boolean): Int
  max: room_member_max_fields
  min: room_member_min_fields
}

"""
order by aggregate values of table "room_member"
"""
input room_member_aggregate_order_by {
  count: order_by
  max: room_member_max_order_by
  min: room_member_min_order_by
}

"""
input type for inserting array relation for remote table "room_member"
"""
input room_member_arr_rel_insert_input {
  data: [room_member_insert_input!]!
  on_conflict: room_member_on_conflict
}

"""
Boolean expression to filter rows from the table "room_member". All fields are combined with a logical 'AND'.
"""
input room_member_bool_exp {
  _and: [room_member_bool_exp]
  _not: room_member_bool_exp
  _or: [room_member_bool_exp]
  room: room_bool_exp
  room_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "room_member"
"""
enum room_member_constraint {
  """
  unique or primary key constraint
  """
  room_participants_pkey

  """
  unique or primary key constraint
  """
  room_participants_room_id_user_id_key
}

"""
input type for inserting data into table "room_member"
"""
input room_member_insert_input {
  room: room_obj_rel_insert_input
  room_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type room_member_max_fields {
  room_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "room_member"
"""
input room_member_max_order_by {
  room_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type room_member_min_fields {
  room_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "room_member"
"""
input room_member_min_order_by {
  room_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "room_member"
"""
type room_member_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [room_member!]!
}

"""
input type for inserting object relation for remote table "room_member"
"""
input room_member_obj_rel_insert_input {
  data: room_member_insert_input!
  on_conflict: room_member_on_conflict
}

"""
on conflict condition type for table "room_member"
"""
input room_member_on_conflict {
  constraint: room_member_constraint!
  update_columns: [room_member_update_column!]!
  where: room_member_bool_exp
}

"""
ordering options when selecting data from "room_member"
"""
input room_member_order_by {
  room: room_order_by
  room_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "room_member"
"""
input room_member_pk_columns_input {
  room_id: uuid!
  user_id: uuid!
}

"""
select columns of table "room_member"
"""
enum room_member_select_column {
  """
  column name
  """
  room_id

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "room_member"
"""
input room_member_set_input {
  room_id: uuid
  user_id: uuid
}

"""
update columns of table "room_member"
"""
enum room_member_update_column {
  """
  column name
  """
  room_id

  """
  column name
  """
  user_id
}

"""
aggregate min on columns
"""
type room_min_fields {
  created_at: timestamptz
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  last_activity_at: timestamptz
  name: String
  notification_job_id: String
  slug: String
  source_google_calendar_event_id: String
  space_id: uuid
  summary: String
}

"""
order by min() on columns of table "room"
"""
input room_min_order_by {
  created_at: order_by
  creator_id: order_by
  deadline: order_by
  finished_at: order_by
  id: order_by
  last_activity_at: order_by
  name: order_by
  notification_job_id: order_by
  slug: order_by
  source_google_calendar_event_id: order_by
  space_id: order_by
  summary: order_by
}

"""
response of any mutation on the table "room"
"""
type room_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [room!]!
}

"""
input type for inserting object relation for remote table "room"
"""
input room_obj_rel_insert_input {
  data: room_insert_input!
  on_conflict: room_on_conflict
}

"""
on conflict condition type for table "room"
"""
input room_on_conflict {
  constraint: room_constraint!
  update_columns: [room_update_column!]!
  where: room_bool_exp
}

"""
ordering options when selecting data from "room"
"""
input room_order_by {
  created_at: order_by
  creator: user_order_by
  creator_id: order_by
  deadline: order_by
  finished_at: order_by
  id: order_by
  invitations_aggregate: room_invitation_aggregate_order_by
  is_private: order_by
  last_activity_at: order_by
  last_posted_message: room_last_posted_message_order_by
  members_aggregate: room_member_aggregate_order_by
  name: order_by
  notification_job_id: order_by
  slug: order_by
  source_google_calendar_event_id: order_by
  space: space_order_by
  space_id: order_by
  summary: order_by
  topics_aggregate: topic_aggregate_order_by
}

"""
primary key columns input for table: "room"
"""
input room_pk_columns_input {
  id: uuid!
}

"""
select columns of table "room"
"""
enum room_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  creator_id

  """
  column name
  """
  deadline

  """
  column name
  """
  finished_at

  """
  column name
  """
  id

  """
  column name
  """
  is_private

  """
  column name
  """
  last_activity_at

  """
  column name
  """
  name

  """
  column name
  """
  notification_job_id

  """
  column name
  """
  slug

  """
  column name
  """
  source_google_calendar_event_id

  """
  column name
  """
  space_id

  """
  column name
  """
  summary
}

"""
input type for updating data in table "room"
"""
input room_set_input {
  created_at: timestamptz
  creator_id: uuid
  deadline: timestamptz
  finished_at: timestamptz
  id: uuid
  is_private: Boolean
  last_activity_at: timestamptz
  name: String
  notification_job_id: String
  slug: String
  source_google_calendar_event_id: String
  space_id: uuid
  summary: String
}

"""
update columns of table "room"
"""
enum room_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  creator_id

  """
  column name
  """
  deadline

  """
  column name
  """
  finished_at

  """
  column name
  """
  id

  """
  column name
  """
  is_private

  """
  column name
  """
  last_activity_at

  """
  column name
  """
  name

  """
  column name
  """
  notification_job_id

  """
  column name
  """
  slug

  """
  column name
  """
  source_google_calendar_event_id

  """
  column name
  """
  space_id

  """
  column name
  """
  summary
}

"""
columns and relationships of "space"
"""
type space {
  """
  An object relationship
  """
  creator: user
  creator_id: uuid!
  id: uuid!

  """
  An array relationship
  """
  members(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): [space_member!]!

  """
  An aggregated array relationship
  """
  members_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): space_member_aggregate!
  name: String!

  """
  An array relationship
  """
  rooms(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): [room!]!

  """
  An aggregated array relationship
  """
  rooms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): room_aggregate!
  slug: String!

  """
  An object relationship
  """
  team: team!
  team_id: uuid!
}

"""
aggregated selection of "space"
"""
type space_aggregate {
  aggregate: space_aggregate_fields
  nodes: [space!]!
}

"""
aggregate fields of "space"
"""
type space_aggregate_fields {
  count(columns: [space_select_column!], distinct: Boolean): Int
  max: space_max_fields
  min: space_min_fields
}

"""
order by aggregate values of table "space"
"""
input space_aggregate_order_by {
  count: order_by
  max: space_max_order_by
  min: space_min_order_by
}

"""
input type for inserting array relation for remote table "space"
"""
input space_arr_rel_insert_input {
  data: [space_insert_input!]!
  on_conflict: space_on_conflict
}

"""
Boolean expression to filter rows from the table "space". All fields are combined with a logical 'AND'.
"""
input space_bool_exp {
  _and: [space_bool_exp]
  _not: space_bool_exp
  _or: [space_bool_exp]
  creator: user_bool_exp
  creator_id: uuid_comparison_exp
  id: uuid_comparison_exp
  members: space_member_bool_exp
  name: String_comparison_exp
  rooms: room_bool_exp
  slug: String_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "space"
"""
enum space_constraint {
  """
  unique or primary key constraint
  """
  space_pkey

  """
  unique or primary key constraint
  """
  space_team_id_slug_key
}

"""
input type for inserting data into table "space"
"""
input space_insert_input {
  creator: user_obj_rel_insert_input
  creator_id: uuid
  id: uuid
  members: space_member_arr_rel_insert_input
  name: String
  rooms: room_arr_rel_insert_input
  slug: String
  team: team_obj_rel_insert_input
  team_id: uuid
}

"""
aggregate max on columns
"""
type space_max_fields {
  creator_id: uuid
  id: uuid
  name: String
  slug: String
  team_id: uuid
}

"""
order by max() on columns of table "space"
"""
input space_max_order_by {
  creator_id: order_by
  id: order_by
  name: order_by
  slug: order_by
  team_id: order_by
}

"""
columns and relationships of "space_member"
"""
type space_member {
  """
  An object relationship
  """
  space: space!
  space_id: uuid!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "space_member"
"""
type space_member_aggregate {
  aggregate: space_member_aggregate_fields
  nodes: [space_member!]!
}

"""
aggregate fields of "space_member"
"""
type space_member_aggregate_fields {
  count(columns: [space_member_select_column!], distinct: Boolean): Int
  max: space_member_max_fields
  min: space_member_min_fields
}

"""
order by aggregate values of table "space_member"
"""
input space_member_aggregate_order_by {
  count: order_by
  max: space_member_max_order_by
  min: space_member_min_order_by
}

"""
input type for inserting array relation for remote table "space_member"
"""
input space_member_arr_rel_insert_input {
  data: [space_member_insert_input!]!
  on_conflict: space_member_on_conflict
}

"""
Boolean expression to filter rows from the table "space_member". All fields are combined with a logical 'AND'.
"""
input space_member_bool_exp {
  _and: [space_member_bool_exp]
  _not: space_member_bool_exp
  _or: [space_member_bool_exp]
  space: space_bool_exp
  space_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "space_member"
"""
enum space_member_constraint {
  """
  unique or primary key constraint
  """
  space_participants_pkey
}

"""
input type for inserting data into table "space_member"
"""
input space_member_insert_input {
  space: space_obj_rel_insert_input
  space_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type space_member_max_fields {
  space_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "space_member"
"""
input space_member_max_order_by {
  space_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type space_member_min_fields {
  space_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "space_member"
"""
input space_member_min_order_by {
  space_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "space_member"
"""
type space_member_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [space_member!]!
}

"""
input type for inserting object relation for remote table "space_member"
"""
input space_member_obj_rel_insert_input {
  data: space_member_insert_input!
  on_conflict: space_member_on_conflict
}

"""
on conflict condition type for table "space_member"
"""
input space_member_on_conflict {
  constraint: space_member_constraint!
  update_columns: [space_member_update_column!]!
  where: space_member_bool_exp
}

"""
ordering options when selecting data from "space_member"
"""
input space_member_order_by {
  space: space_order_by
  space_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "space_member"
"""
input space_member_pk_columns_input {
  space_id: uuid!
  user_id: uuid!
}

"""
select columns of table "space_member"
"""
enum space_member_select_column {
  """
  column name
  """
  space_id

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "space_member"
"""
input space_member_set_input {
  space_id: uuid
  user_id: uuid
}

"""
update columns of table "space_member"
"""
enum space_member_update_column {
  """
  column name
  """
  space_id

  """
  column name
  """
  user_id
}

"""
aggregate min on columns
"""
type space_min_fields {
  creator_id: uuid
  id: uuid
  name: String
  slug: String
  team_id: uuid
}

"""
order by min() on columns of table "space"
"""
input space_min_order_by {
  creator_id: order_by
  id: order_by
  name: order_by
  slug: order_by
  team_id: order_by
}

"""
response of any mutation on the table "space"
"""
type space_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [space!]!
}

"""
input type for inserting object relation for remote table "space"
"""
input space_obj_rel_insert_input {
  data: space_insert_input!
  on_conflict: space_on_conflict
}

"""
on conflict condition type for table "space"
"""
input space_on_conflict {
  constraint: space_constraint!
  update_columns: [space_update_column!]!
  where: space_bool_exp
}

"""
ordering options when selecting data from "space"
"""
input space_order_by {
  creator: user_order_by
  creator_id: order_by
  id: order_by
  members_aggregate: space_member_aggregate_order_by
  name: order_by
  rooms_aggregate: room_aggregate_order_by
  slug: order_by
  team: team_order_by
  team_id: order_by
}

"""
primary key columns input for table: "space"
"""
input space_pk_columns_input {
  id: uuid!
}

"""
select columns of table "space"
"""
enum space_select_column {
  """
  column name
  """
  creator_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  slug

  """
  column name
  """
  team_id
}

"""
input type for updating data in table "space"
"""
input space_set_input {
  creator_id: uuid
  id: uuid
  name: String
  slug: String
  team_id: uuid
}

"""
update columns of table "space"
"""
enum space_update_column {
  """
  column name
  """
  creator_id

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  slug

  """
  column name
  """
  team_id
}

"""
subscription root
"""
type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """
    distinct select on columns
    """
    distinct_on: [account_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [account_order_by!]

    """
    filter the rows returned
    """
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [account_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [account_order_by!]

    """
    filter the rows returned
    """
    where: account_bool_exp
  ): account_aggregate!

  """
  fetch data from the table: "account" using primary key columns
  """
  account_by_pk(id: uuid!): account

  """
  fetch data from the table: "attachment"
  """
  attachment(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): [attachment!]!

  """
  fetch aggregated fields from the table: "attachment"
  """
  attachment_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): attachment_aggregate!

  """
  fetch data from the table: "attachment" using primary key columns
  """
  attachment_by_pk(id: uuid!): attachment

  """
  perform the action: "get_download_url"
  """
  get_download_url(uuid: uuid!): DownloadUrlResponse

  """
  perform the action: "get_upload_url"
  """
  get_upload_url(fileName: String!, mimeType: String!): UploadUrlResponse

  """
  fetch data from the table: "last_seen_message"
  """
  last_seen_message(
    """
    distinct select on columns
    """
    distinct_on: [last_seen_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [last_seen_message_order_by!]

    """
    filter the rows returned
    """
    where: last_seen_message_bool_exp
  ): [last_seen_message!]!

  """
  fetch aggregated fields from the table: "last_seen_message"
  """
  last_seen_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [last_seen_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [last_seen_message_order_by!]

    """
    filter the rows returned
    """
    where: last_seen_message_bool_exp
  ): last_seen_message_aggregate!

  """
  fetch data from the table: "last_seen_message" using primary key columns
  """
  last_seen_message_by_pk(topic_id: uuid!, user_id: uuid!): last_seen_message

  """
  perform the action: "lookup_team_name"
  """
  lookup_team_name(token: String!): LookupTeamNameResponse

  """
  fetch data from the table: "membership_status"
  """
  membership_status(
    """
    distinct select on columns
    """
    distinct_on: [membership_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [membership_status_order_by!]

    """
    filter the rows returned
    """
    where: membership_status_bool_exp
  ): [membership_status!]!

  """
  fetch aggregated fields from the table: "membership_status"
  """
  membership_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [membership_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [membership_status_order_by!]

    """
    filter the rows returned
    """
    where: membership_status_bool_exp
  ): membership_status_aggregate!

  """
  fetch data from the table: "membership_status" using primary key columns
  """
  membership_status_by_pk(value: String!): membership_status

  """
  fetch data from the table: "message"
  """
  message(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!

  """
  fetch data from the table: "message" using primary key columns
  """
  message_by_pk(id: uuid!): message

  """
  fetch data from the table: "message_reaction"
  """
  message_reaction(
    """
    distinct select on columns
    """
    distinct_on: [message_reaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_reaction_order_by!]

    """
    filter the rows returned
    """
    where: message_reaction_bool_exp
  ): [message_reaction!]!

  """
  fetch aggregated fields from the table: "message_reaction"
  """
  message_reaction_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_reaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_reaction_order_by!]

    """
    filter the rows returned
    """
    where: message_reaction_bool_exp
  ): message_reaction_aggregate!

  """
  fetch data from the table: "message_reaction" using primary key columns
  """
  message_reaction_by_pk(emoji: String!, message_id: uuid!, user_id: uuid!): message_reaction

  """
  fetch data from the table: "message_type"
  """
  message_type(
    """
    distinct select on columns
    """
    distinct_on: [message_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_type_order_by!]

    """
    filter the rows returned
    """
    where: message_type_bool_exp
  ): [message_type!]!

  """
  fetch aggregated fields from the table: "message_type"
  """
  message_type_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_type_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_type_order_by!]

    """
    filter the rows returned
    """
    where: message_type_bool_exp
  ): message_type_aggregate!

  """
  fetch data from the table: "message_type" using primary key columns
  """
  message_type_by_pk(value: String!): message_type

  """
  fetch data from the table: "notification"
  """
  notification(
    """
    distinct select on columns
    """
    distinct_on: [notification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [notification_order_by!]

    """
    filter the rows returned
    """
    where: notification_bool_exp
  ): [notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notification_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [notification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [notification_order_by!]

    """
    filter the rows returned
    """
    where: notification_bool_exp
  ): notification_aggregate!

  """
  fetch data from the table: "notification" using primary key columns
  """
  notification_by_pk(id: uuid!): notification

  """
  fetch data from the table: "room"
  """
  room(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): [room!]!

  """
  fetch aggregated fields from the table: "room"
  """
  room_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): room_aggregate!

  """
  fetch data from the table: "room" using primary key columns
  """
  room_by_pk(id: uuid!): room

  """
  fetch data from the table: "room_invitation"
  """
  room_invitation(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): [room_invitation!]!

  """
  fetch aggregated fields from the table: "room_invitation"
  """
  room_invitation_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): room_invitation_aggregate!

  """
  fetch data from the table: "room_invitation" using primary key columns
  """
  room_invitation_by_pk(id: uuid!): room_invitation

  """
  perform the action: "room_invitation_view"
  """
  room_invitation_view(token: String!): RoomInvitationViewResponse

  """
  fetch data from the table: "room_last_posted_message"
  """
  room_last_posted_message(
    """
    distinct select on columns
    """
    distinct_on: [room_last_posted_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_last_posted_message_order_by!]

    """
    filter the rows returned
    """
    where: room_last_posted_message_bool_exp
  ): [room_last_posted_message!]!

  """
  fetch aggregated fields from the table: "room_last_posted_message"
  """
  room_last_posted_message_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_last_posted_message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_last_posted_message_order_by!]

    """
    filter the rows returned
    """
    where: room_last_posted_message_bool_exp
  ): room_last_posted_message_aggregate!

  """
  fetch data from the table: "room_member"
  """
  room_member(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): [room_member!]!

  """
  fetch aggregated fields from the table: "room_member"
  """
  room_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): room_member_aggregate!

  """
  fetch data from the table: "room_member" using primary key columns
  """
  room_member_by_pk(room_id: uuid!, user_id: uuid!): room_member

  """
  fetch data from the table: "space"
  """
  space(
    """
    distinct select on columns
    """
    distinct_on: [space_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_order_by!]

    """
    filter the rows returned
    """
    where: space_bool_exp
  ): [space!]!

  """
  fetch aggregated fields from the table: "space"
  """
  space_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_order_by!]

    """
    filter the rows returned
    """
    where: space_bool_exp
  ): space_aggregate!

  """
  fetch data from the table: "space" using primary key columns
  """
  space_by_pk(id: uuid!): space

  """
  fetch data from the table: "space_member"
  """
  space_member(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): [space_member!]!

  """
  fetch aggregated fields from the table: "space_member"
  """
  space_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): space_member_aggregate!

  """
  fetch data from the table: "space_member" using primary key columns
  """
  space_member_by_pk(space_id: uuid!, user_id: uuid!): space_member

  """
  fetch data from the table: "team"
  """
  team(
    """
    distinct select on columns
    """
    distinct_on: [team_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_order_by!]

    """
    filter the rows returned
    """
    where: team_bool_exp
  ): [team!]!

  """
  fetch aggregated fields from the table: "team"
  """
  team_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_order_by!]

    """
    filter the rows returned
    """
    where: team_bool_exp
  ): team_aggregate!

  """
  fetch data from the table: "team" using primary key columns
  """
  team_by_pk(id: uuid!): team

  """
  fetch data from the table: "team_invitation"
  """
  team_invitation(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): [team_invitation!]!

  """
  fetch aggregated fields from the table: "team_invitation"
  """
  team_invitation_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): team_invitation_aggregate!

  """
  fetch data from the table: "team_invitation" using primary key columns
  """
  team_invitation_by_pk(id: uuid!): team_invitation

  """
  fetch data from the table: "team_member"
  """
  team_member(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): [team_member!]!

  """
  fetch aggregated fields from the table: "team_member"
  """
  team_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): team_member_aggregate!

  """
  fetch data from the table: "team_member" using primary key columns
  """
  team_member_by_pk(team_id: uuid!, user_id: uuid!): team_member

  """
  fetch data from the table: "topic"
  """
  topic(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  fetch aggregated fields from the table: "topic"
  """
  topic_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!

  """
  fetch data from the table: "topic" using primary key columns
  """
  topic_by_pk(id: uuid!): topic

  """
  fetch data from the table: "topic_member"
  """
  topic_member(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): [topic_member!]!

  """
  fetch aggregated fields from the table: "topic_member"
  """
  topic_member_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): topic_member_aggregate!

  """
  fetch data from the table: "topic_member" using primary key columns
  """
  topic_member_by_pk(topic_id: uuid!, user_id: uuid!): topic_member

  """
  fetch data from the table: "transcription"
  """
  transcription(
    """
    distinct select on columns
    """
    distinct_on: [transcription_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_order_by!]

    """
    filter the rows returned
    """
    where: transcription_bool_exp
  ): [transcription!]!

  """
  fetch aggregated fields from the table: "transcription"
  """
  transcription_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [transcription_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_order_by!]

    """
    filter the rows returned
    """
    where: transcription_bool_exp
  ): transcription_aggregate!

  """
  fetch data from the table: "transcription" using primary key columns
  """
  transcription_by_pk(id: uuid!): transcription

  """
  fetch data from the table: "transcription_status"
  """
  transcription_status(
    """
    distinct select on columns
    """
    distinct_on: [transcription_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_status_order_by!]

    """
    filter the rows returned
    """
    where: transcription_status_bool_exp
  ): [transcription_status!]!

  """
  fetch aggregated fields from the table: "transcription_status"
  """
  transcription_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [transcription_status_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [transcription_status_order_by!]

    """
    filter the rows returned
    """
    where: transcription_status_bool_exp
  ): transcription_status_aggregate!

  """
  fetch data from the table: "transcription_status" using primary key columns
  """
  transcription_status_by_pk(value: String!): transcription_status

  """
  fetch data from the table: "unread_messages"
  """
  unread_messages(
    """
    distinct select on columns
    """
    distinct_on: [unread_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [unread_messages_order_by!]

    """
    filter the rows returned
    """
    where: unread_messages_bool_exp
  ): [unread_messages!]!

  """
  fetch aggregated fields from the table: "unread_messages"
  """
  unread_messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [unread_messages_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [unread_messages_order_by!]

    """
    filter the rows returned
    """
    where: unread_messages_bool_exp
  ): unread_messages_aggregate!

  """
  fetch data from the table: "user"
  """
  user(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  fetch data from the table: "user" using primary key columns
  """
  user_by_pk(id: uuid!): user

  """
  fetch data from the table: "whitelist"
  """
  whitelist(
    """
    distinct select on columns
    """
    distinct_on: [whitelist_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [whitelist_order_by!]

    """
    filter the rows returned
    """
    where: whitelist_bool_exp
  ): [whitelist!]!

  """
  fetch aggregated fields from the table: "whitelist"
  """
  whitelist_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [whitelist_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [whitelist_order_by!]

    """
    filter the rows returned
    """
    where: whitelist_bool_exp
  ): whitelist_aggregate!

  """
  fetch data from the table: "whitelist" using primary key columns
  """
  whitelist_by_pk(email: String!): whitelist
}

"""
columns and relationships of "team"
"""
type team {
  id: uuid!

  """
  An array relationship
  """
  invitations(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): [team_invitation!]!

  """
  An aggregated array relationship
  """
  invitations_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): team_invitation_aggregate!

  """
  An array relationship
  """
  memberships(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): [team_member!]!

  """
  An aggregated array relationship
  """
  memberships_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): team_member_aggregate!
  name: String!

  """
  An object relationship
  """
  owner: user!
  owner_id: uuid!
  slug: String!

  """
  An array relationship
  """
  spaces(
    """
    distinct select on columns
    """
    distinct_on: [space_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_order_by!]

    """
    filter the rows returned
    """
    where: space_bool_exp
  ): [space!]!

  """
  An aggregated array relationship
  """
  spaces_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_order_by!]

    """
    filter the rows returned
    """
    where: space_bool_exp
  ): space_aggregate!
}

"""
aggregated selection of "team"
"""
type team_aggregate {
  aggregate: team_aggregate_fields
  nodes: [team!]!
}

"""
aggregate fields of "team"
"""
type team_aggregate_fields {
  count(columns: [team_select_column!], distinct: Boolean): Int
  max: team_max_fields
  min: team_min_fields
}

"""
order by aggregate values of table "team"
"""
input team_aggregate_order_by {
  count: order_by
  max: team_max_order_by
  min: team_min_order_by
}

"""
input type for inserting array relation for remote table "team"
"""
input team_arr_rel_insert_input {
  data: [team_insert_input!]!
  on_conflict: team_on_conflict
}

"""
Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
"""
input team_bool_exp {
  _and: [team_bool_exp]
  _not: team_bool_exp
  _or: [team_bool_exp]
  id: uuid_comparison_exp
  invitations: team_invitation_bool_exp
  memberships: team_member_bool_exp
  name: String_comparison_exp
  owner: user_bool_exp
  owner_id: uuid_comparison_exp
  slug: String_comparison_exp
  spaces: space_bool_exp
}

"""
unique or primary key constraints on table "team"
"""
enum team_constraint {
  """
  unique or primary key constraint
  """
  team_id_key

  """
  unique or primary key constraint
  """
  team_pkey

  """
  unique or primary key constraint
  """
  team_slug_key
}

"""
input type for inserting data into table "team"
"""
input team_insert_input {
  id: uuid
  invitations: team_invitation_arr_rel_insert_input
  memberships: team_member_arr_rel_insert_input
  name: String
  owner: user_obj_rel_insert_input
  owner_id: uuid
  slug: String
  spaces: space_arr_rel_insert_input
}

"""
columns and relationships of "team_invitation"
"""
type team_invitation {
  created_at: timestamptz!
  email: String!
  id: uuid!

  """
  An object relationship
  """
  inviting_user: user!
  inviting_user_id: uuid!

  """
  An object relationship
  """
  team: team!
  team_id: uuid!
  token: uuid!
  used_at: date

  """
  An object relationship
  """
  used_by_user: user
  used_by_user_id: uuid
}

"""
aggregated selection of "team_invitation"
"""
type team_invitation_aggregate {
  aggregate: team_invitation_aggregate_fields
  nodes: [team_invitation!]!
}

"""
aggregate fields of "team_invitation"
"""
type team_invitation_aggregate_fields {
  count(columns: [team_invitation_select_column!], distinct: Boolean): Int
  max: team_invitation_max_fields
  min: team_invitation_min_fields
}

"""
order by aggregate values of table "team_invitation"
"""
input team_invitation_aggregate_order_by {
  count: order_by
  max: team_invitation_max_order_by
  min: team_invitation_min_order_by
}

"""
input type for inserting array relation for remote table "team_invitation"
"""
input team_invitation_arr_rel_insert_input {
  data: [team_invitation_insert_input!]!
  on_conflict: team_invitation_on_conflict
}

"""
Boolean expression to filter rows from the table "team_invitation". All fields are combined with a logical 'AND'.
"""
input team_invitation_bool_exp {
  _and: [team_invitation_bool_exp]
  _not: team_invitation_bool_exp
  _or: [team_invitation_bool_exp]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  inviting_user: user_bool_exp
  inviting_user_id: uuid_comparison_exp
  team: team_bool_exp
  team_id: uuid_comparison_exp
  token: uuid_comparison_exp
  used_at: date_comparison_exp
  used_by_user: user_bool_exp
  used_by_user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "team_invitation"
"""
enum team_invitation_constraint {
  """
  unique or primary key constraint
  """
  team_invitation_pkey

  """
  unique or primary key constraint
  """
  team_invitation_token_key
}

"""
input type for inserting data into table "team_invitation"
"""
input team_invitation_insert_input {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user: user_obj_rel_insert_input
  inviting_user_id: uuid
  team: team_obj_rel_insert_input
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user: user_obj_rel_insert_input
  used_by_user_id: uuid
}

"""
aggregate max on columns
"""
type team_invitation_max_fields {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user_id: uuid
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user_id: uuid
}

"""
order by max() on columns of table "team_invitation"
"""
input team_invitation_max_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  inviting_user_id: order_by
  team_id: order_by
  token: order_by
  used_at: order_by
  used_by_user_id: order_by
}

"""
aggregate min on columns
"""
type team_invitation_min_fields {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user_id: uuid
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user_id: uuid
}

"""
order by min() on columns of table "team_invitation"
"""
input team_invitation_min_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  inviting_user_id: order_by
  team_id: order_by
  token: order_by
  used_at: order_by
  used_by_user_id: order_by
}

"""
response of any mutation on the table "team_invitation"
"""
type team_invitation_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [team_invitation!]!
}

"""
input type for inserting object relation for remote table "team_invitation"
"""
input team_invitation_obj_rel_insert_input {
  data: team_invitation_insert_input!
  on_conflict: team_invitation_on_conflict
}

"""
on conflict condition type for table "team_invitation"
"""
input team_invitation_on_conflict {
  constraint: team_invitation_constraint!
  update_columns: [team_invitation_update_column!]!
  where: team_invitation_bool_exp
}

"""
ordering options when selecting data from "team_invitation"
"""
input team_invitation_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  inviting_user: user_order_by
  inviting_user_id: order_by
  team: team_order_by
  team_id: order_by
  token: order_by
  used_at: order_by
  used_by_user: user_order_by
  used_by_user_id: order_by
}

"""
primary key columns input for table: "team_invitation"
"""
input team_invitation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team_invitation"
"""
enum team_invitation_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  inviting_user_id

  """
  column name
  """
  team_id

  """
  column name
  """
  token

  """
  column name
  """
  used_at

  """
  column name
  """
  used_by_user_id
}

"""
input type for updating data in table "team_invitation"
"""
input team_invitation_set_input {
  created_at: timestamptz
  email: String
  id: uuid
  inviting_user_id: uuid
  team_id: uuid
  token: uuid
  used_at: date
  used_by_user_id: uuid
}

"""
update columns of table "team_invitation"
"""
enum team_invitation_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  inviting_user_id

  """
  column name
  """
  team_id

  """
  column name
  """
  token

  """
  column name
  """
  used_at

  """
  column name
  """
  used_by_user_id
}

"""
aggregate max on columns
"""
type team_max_fields {
  id: uuid
  name: String
  owner_id: uuid
  slug: String
}

"""
order by max() on columns of table "team"
"""
input team_max_order_by {
  id: order_by
  name: order_by
  owner_id: order_by
  slug: order_by
}

"""
columns and relationships of "team_member"
"""
type team_member {
  """
  An object relationship
  """
  team: team!
  team_id: uuid!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "team_member"
"""
type team_member_aggregate {
  aggregate: team_member_aggregate_fields
  nodes: [team_member!]!
}

"""
aggregate fields of "team_member"
"""
type team_member_aggregate_fields {
  count(columns: [team_member_select_column!], distinct: Boolean): Int
  max: team_member_max_fields
  min: team_member_min_fields
}

"""
order by aggregate values of table "team_member"
"""
input team_member_aggregate_order_by {
  count: order_by
  max: team_member_max_order_by
  min: team_member_min_order_by
}

"""
input type for inserting array relation for remote table "team_member"
"""
input team_member_arr_rel_insert_input {
  data: [team_member_insert_input!]!
  on_conflict: team_member_on_conflict
}

"""
Boolean expression to filter rows from the table "team_member". All fields are combined with a logical 'AND'.
"""
input team_member_bool_exp {
  _and: [team_member_bool_exp]
  _not: team_member_bool_exp
  _or: [team_member_bool_exp]
  team: team_bool_exp
  team_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "team_member"
"""
enum team_member_constraint {
  """
  unique or primary key constraint
  """
  team_membership_pkey
}

"""
input type for inserting data into table "team_member"
"""
input team_member_insert_input {
  team: team_obj_rel_insert_input
  team_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type team_member_max_fields {
  team_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "team_member"
"""
input team_member_max_order_by {
  team_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type team_member_min_fields {
  team_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "team_member"
"""
input team_member_min_order_by {
  team_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "team_member"
"""
type team_member_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [team_member!]!
}

"""
input type for inserting object relation for remote table "team_member"
"""
input team_member_obj_rel_insert_input {
  data: team_member_insert_input!
  on_conflict: team_member_on_conflict
}

"""
on conflict condition type for table "team_member"
"""
input team_member_on_conflict {
  constraint: team_member_constraint!
  update_columns: [team_member_update_column!]!
  where: team_member_bool_exp
}

"""
ordering options when selecting data from "team_member"
"""
input team_member_order_by {
  team: team_order_by
  team_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "team_member"
"""
input team_member_pk_columns_input {
  team_id: uuid!
  user_id: uuid!
}

"""
select columns of table "team_member"
"""
enum team_member_select_column {
  """
  column name
  """
  team_id

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "team_member"
"""
input team_member_set_input {
  team_id: uuid
  user_id: uuid
}

"""
update columns of table "team_member"
"""
enum team_member_update_column {
  """
  column name
  """
  team_id

  """
  column name
  """
  user_id
}

"""
aggregate min on columns
"""
type team_min_fields {
  id: uuid
  name: String
  owner_id: uuid
  slug: String
}

"""
order by min() on columns of table "team"
"""
input team_min_order_by {
  id: order_by
  name: order_by
  owner_id: order_by
  slug: order_by
}

"""
response of any mutation on the table "team"
"""
type team_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [team!]!
}

"""
input type for inserting object relation for remote table "team"
"""
input team_obj_rel_insert_input {
  data: team_insert_input!
  on_conflict: team_on_conflict
}

"""
on conflict condition type for table "team"
"""
input team_on_conflict {
  constraint: team_constraint!
  update_columns: [team_update_column!]!
  where: team_bool_exp
}

"""
ordering options when selecting data from "team"
"""
input team_order_by {
  id: order_by
  invitations_aggregate: team_invitation_aggregate_order_by
  memberships_aggregate: team_member_aggregate_order_by
  name: order_by
  owner: user_order_by
  owner_id: order_by
  slug: order_by
  spaces_aggregate: space_aggregate_order_by
}

"""
primary key columns input for table: "team"
"""
input team_pk_columns_input {
  id: uuid!
}

"""
select columns of table "team"
"""
enum team_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  owner_id

  """
  column name
  """
  slug
}

"""
input type for updating data in table "team"
"""
input team_set_input {
  id: uuid
  name: String
  owner_id: uuid
  slug: String
}

"""
update columns of table "team"
"""
enum team_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  owner_id

  """
  column name
  """
  slug
}

scalar timestamp

"""
expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "topic"
"""
type topic {
  closed_at: timestamp

  """
  An object relationship
  """
  closed_by_user: user
  closed_by_user_id: uuid
  closing_summary: String
  id: uuid!
  index: String!

  """
  An array relationship
  """
  members(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): [topic_member!]!

  """
  An aggregated array relationship
  """
  members_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): topic_member_aggregate!

  """
  An array relationship
  """
  messages(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  An aggregated array relationship
  """
  messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!
  name: String!

  """
  An object relationship
  """
  room: room!
  room_id: uuid!
  slug: String!
}

"""
aggregated selection of "topic"
"""
type topic_aggregate {
  aggregate: topic_aggregate_fields
  nodes: [topic!]!
}

"""
aggregate fields of "topic"
"""
type topic_aggregate_fields {
  count(columns: [topic_select_column!], distinct: Boolean): Int
  max: topic_max_fields
  min: topic_min_fields
}

"""
order by aggregate values of table "topic"
"""
input topic_aggregate_order_by {
  count: order_by
  max: topic_max_order_by
  min: topic_min_order_by
}

"""
input type for inserting array relation for remote table "topic"
"""
input topic_arr_rel_insert_input {
  data: [topic_insert_input!]!
  on_conflict: topic_on_conflict
}

"""
Boolean expression to filter rows from the table "topic". All fields are combined with a logical 'AND'.
"""
input topic_bool_exp {
  _and: [topic_bool_exp]
  _not: topic_bool_exp
  _or: [topic_bool_exp]
  closed_at: timestamp_comparison_exp
  closed_by_user: user_bool_exp
  closed_by_user_id: uuid_comparison_exp
  closing_summary: String_comparison_exp
  id: uuid_comparison_exp
  index: String_comparison_exp
  members: topic_member_bool_exp
  messages: message_bool_exp
  name: String_comparison_exp
  room: room_bool_exp
  room_id: uuid_comparison_exp
  slug: String_comparison_exp
}

"""
unique or primary key constraints on table "topic"
"""
enum topic_constraint {
  """
  unique or primary key constraint
  """
  thread_pkey

  """
  unique or primary key constraint
  """
  topic_slug_room_id_key
}

"""
input type for inserting data into table "topic"
"""
input topic_insert_input {
  closed_at: timestamp
  closed_by_user: user_obj_rel_insert_input
  closed_by_user_id: uuid
  closing_summary: String
  id: uuid
  index: String
  members: topic_member_arr_rel_insert_input
  messages: message_arr_rel_insert_input
  name: String
  room: room_obj_rel_insert_input
  room_id: uuid
  slug: String
}

"""
aggregate max on columns
"""
type topic_max_fields {
  closed_at: timestamp
  closed_by_user_id: uuid
  closing_summary: String
  id: uuid
  index: String
  name: String
  room_id: uuid
  slug: String
}

"""
order by max() on columns of table "topic"
"""
input topic_max_order_by {
  closed_at: order_by
  closed_by_user_id: order_by
  closing_summary: order_by
  id: order_by
  index: order_by
  name: order_by
  room_id: order_by
  slug: order_by
}

"""
columns and relationships of "topic_member"
"""
type topic_member {
  """
  An object relationship
  """
  topic: topic!
  topic_id: uuid!

  """
  An object relationship
  """
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "topic_member"
"""
type topic_member_aggregate {
  aggregate: topic_member_aggregate_fields
  nodes: [topic_member!]!
}

"""
aggregate fields of "topic_member"
"""
type topic_member_aggregate_fields {
  count(columns: [topic_member_select_column!], distinct: Boolean): Int
  max: topic_member_max_fields
  min: topic_member_min_fields
}

"""
order by aggregate values of table "topic_member"
"""
input topic_member_aggregate_order_by {
  count: order_by
  max: topic_member_max_order_by
  min: topic_member_min_order_by
}

"""
input type for inserting array relation for remote table "topic_member"
"""
input topic_member_arr_rel_insert_input {
  data: [topic_member_insert_input!]!
  on_conflict: topic_member_on_conflict
}

"""
Boolean expression to filter rows from the table "topic_member". All fields are combined with a logical 'AND'.
"""
input topic_member_bool_exp {
  _and: [topic_member_bool_exp]
  _not: topic_member_bool_exp
  _or: [topic_member_bool_exp]
  topic: topic_bool_exp
  topic_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "topic_member"
"""
enum topic_member_constraint {
  """
  unique or primary key constraint
  """
  topic_participants_pkey
}

"""
input type for inserting data into table "topic_member"
"""
input topic_member_insert_input {
  topic: topic_obj_rel_insert_input
  topic_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""
aggregate max on columns
"""
type topic_member_max_fields {
  topic_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "topic_member"
"""
input topic_member_max_order_by {
  topic_id: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type topic_member_min_fields {
  topic_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "topic_member"
"""
input topic_member_min_order_by {
  topic_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "topic_member"
"""
type topic_member_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [topic_member!]!
}

"""
input type for inserting object relation for remote table "topic_member"
"""
input topic_member_obj_rel_insert_input {
  data: topic_member_insert_input!
  on_conflict: topic_member_on_conflict
}

"""
on conflict condition type for table "topic_member"
"""
input topic_member_on_conflict {
  constraint: topic_member_constraint!
  update_columns: [topic_member_update_column!]!
  where: topic_member_bool_exp
}

"""
ordering options when selecting data from "topic_member"
"""
input topic_member_order_by {
  topic: topic_order_by
  topic_id: order_by
  user: user_order_by
  user_id: order_by
}

"""
primary key columns input for table: "topic_member"
"""
input topic_member_pk_columns_input {
  topic_id: uuid!
  user_id: uuid!
}

"""
select columns of table "topic_member"
"""
enum topic_member_select_column {
  """
  column name
  """
  topic_id

  """
  column name
  """
  user_id
}

"""
input type for updating data in table "topic_member"
"""
input topic_member_set_input {
  topic_id: uuid
  user_id: uuid
}

"""
update columns of table "topic_member"
"""
enum topic_member_update_column {
  """
  column name
  """
  topic_id

  """
  column name
  """
  user_id
}

"""
aggregate min on columns
"""
type topic_min_fields {
  closed_at: timestamp
  closed_by_user_id: uuid
  closing_summary: String
  id: uuid
  index: String
  name: String
  room_id: uuid
  slug: String
}

"""
order by min() on columns of table "topic"
"""
input topic_min_order_by {
  closed_at: order_by
  closed_by_user_id: order_by
  closing_summary: order_by
  id: order_by
  index: order_by
  name: order_by
  room_id: order_by
  slug: order_by
}

"""
response of any mutation on the table "topic"
"""
type topic_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [topic!]!
}

"""
input type for inserting object relation for remote table "topic"
"""
input topic_obj_rel_insert_input {
  data: topic_insert_input!
  on_conflict: topic_on_conflict
}

"""
on conflict condition type for table "topic"
"""
input topic_on_conflict {
  constraint: topic_constraint!
  update_columns: [topic_update_column!]!
  where: topic_bool_exp
}

"""
ordering options when selecting data from "topic"
"""
input topic_order_by {
  closed_at: order_by
  closed_by_user: user_order_by
  closed_by_user_id: order_by
  closing_summary: order_by
  id: order_by
  index: order_by
  members_aggregate: topic_member_aggregate_order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  room: room_order_by
  room_id: order_by
  slug: order_by
}

"""
primary key columns input for table: "topic"
"""
input topic_pk_columns_input {
  id: uuid!
}

"""
select columns of table "topic"
"""
enum topic_select_column {
  """
  column name
  """
  closed_at

  """
  column name
  """
  closed_by_user_id

  """
  column name
  """
  closing_summary

  """
  column name
  """
  id

  """
  column name
  """
  index

  """
  column name
  """
  name

  """
  column name
  """
  room_id

  """
  column name
  """
  slug
}

"""
input type for updating data in table "topic"
"""
input topic_set_input {
  closed_at: timestamp
  closed_by_user_id: uuid
  closing_summary: String
  id: uuid
  index: String
  name: String
  room_id: uuid
  slug: String
}

"""
update columns of table "topic"
"""
enum topic_update_column {
  """
  column name
  """
  closed_at

  """
  column name
  """
  closed_by_user_id

  """
  column name
  """
  closing_summary

  """
  column name
  """
  id

  """
  column name
  """
  index

  """
  column name
  """
  name

  """
  column name
  """
  room_id

  """
  column name
  """
  slug
}

"""
columns and relationships of "transcription"
"""
type transcription {
  """
  An array relationship
  """
  attachments(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): [attachment!]!

  """
  An aggregated array relationship
  """
  attachments_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [attachment_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [attachment_order_by!]

    """
    filter the rows returned
    """
    where: attachment_bool_exp
  ): attachment_aggregate!
  created_at: timestamptz!
  id: uuid!
  sonix_media_id: String!
  status: transcription_status_enum!
  transcript(
    """
    JSON select path
    """
    path: String
  ): jsonb
  updated_at: timestamptz!
}

"""
aggregated selection of "transcription"
"""
type transcription_aggregate {
  aggregate: transcription_aggregate_fields
  nodes: [transcription!]!
}

"""
aggregate fields of "transcription"
"""
type transcription_aggregate_fields {
  count(columns: [transcription_select_column!], distinct: Boolean): Int
  max: transcription_max_fields
  min: transcription_min_fields
}

"""
order by aggregate values of table "transcription"
"""
input transcription_aggregate_order_by {
  count: order_by
  max: transcription_max_order_by
  min: transcription_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input transcription_append_input {
  transcript: jsonb
}

"""
input type for inserting array relation for remote table "transcription"
"""
input transcription_arr_rel_insert_input {
  data: [transcription_insert_input!]!
  on_conflict: transcription_on_conflict
}

"""
Boolean expression to filter rows from the table "transcription". All fields are combined with a logical 'AND'.
"""
input transcription_bool_exp {
  _and: [transcription_bool_exp]
  _not: transcription_bool_exp
  _or: [transcription_bool_exp]
  attachments: attachment_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  sonix_media_id: String_comparison_exp
  status: transcription_status_enum_comparison_exp
  transcript: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "transcription"
"""
enum transcription_constraint {
  """
  unique or primary key constraint
  """
  transcription_pkey

  """
  unique or primary key constraint
  """
  transcription_sonix_media_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input transcription_delete_at_path_input {
  transcript: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input transcription_delete_elem_input {
  transcript: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input transcription_delete_key_input {
  transcript: String
}

"""
input type for inserting data into table "transcription"
"""
input transcription_insert_input {
  attachments: attachment_arr_rel_insert_input
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  status: transcription_status_enum
  transcript: jsonb
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type transcription_max_fields {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "transcription"
"""
input transcription_max_order_by {
  created_at: order_by
  id: order_by
  sonix_media_id: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type transcription_min_fields {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "transcription"
"""
input transcription_min_order_by {
  created_at: order_by
  id: order_by
  sonix_media_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "transcription"
"""
type transcription_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [transcription!]!
}

"""
input type for inserting object relation for remote table "transcription"
"""
input transcription_obj_rel_insert_input {
  data: transcription_insert_input!
  on_conflict: transcription_on_conflict
}

"""
on conflict condition type for table "transcription"
"""
input transcription_on_conflict {
  constraint: transcription_constraint!
  update_columns: [transcription_update_column!]!
  where: transcription_bool_exp
}

"""
ordering options when selecting data from "transcription"
"""
input transcription_order_by {
  attachments_aggregate: attachment_aggregate_order_by
  created_at: order_by
  id: order_by
  sonix_media_id: order_by
  status: order_by
  transcript: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "transcription"
"""
input transcription_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input transcription_prepend_input {
  transcript: jsonb
}

"""
select columns of table "transcription"
"""
enum transcription_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  sonix_media_id

  """
  column name
  """
  status

  """
  column name
  """
  transcript

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "transcription"
"""
input transcription_set_input {
  created_at: timestamptz
  id: uuid
  sonix_media_id: String
  status: transcription_status_enum
  transcript: jsonb
  updated_at: timestamptz
}

"""
columns and relationships of "transcription_status"
"""
type transcription_status {
  value: String!
}

"""
aggregated selection of "transcription_status"
"""
type transcription_status_aggregate {
  aggregate: transcription_status_aggregate_fields
  nodes: [transcription_status!]!
}

"""
aggregate fields of "transcription_status"
"""
type transcription_status_aggregate_fields {
  count(columns: [transcription_status_select_column!], distinct: Boolean): Int
  max: transcription_status_max_fields
  min: transcription_status_min_fields
}

"""
order by aggregate values of table "transcription_status"
"""
input transcription_status_aggregate_order_by {
  count: order_by
  max: transcription_status_max_order_by
  min: transcription_status_min_order_by
}

"""
input type for inserting array relation for remote table "transcription_status"
"""
input transcription_status_arr_rel_insert_input {
  data: [transcription_status_insert_input!]!
  on_conflict: transcription_status_on_conflict
}

"""
Boolean expression to filter rows from the table "transcription_status". All fields are combined with a logical 'AND'.
"""
input transcription_status_bool_exp {
  _and: [transcription_status_bool_exp]
  _not: transcription_status_bool_exp
  _or: [transcription_status_bool_exp]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "transcription_status"
"""
enum transcription_status_constraint {
  """
  unique or primary key constraint
  """
  transcription_status_pkey
}

enum transcription_status_enum {
  blocked
  completed
  failed
  preparing
  transcribing
}

"""
expression to compare columns of type transcription_status_enum. All fields are combined with logical 'AND'.
"""
input transcription_status_enum_comparison_exp {
  _eq: transcription_status_enum
  _in: [transcription_status_enum!]
  _is_null: Boolean
  _neq: transcription_status_enum
  _nin: [transcription_status_enum!]
}

"""
input type for inserting data into table "transcription_status"
"""
input transcription_status_insert_input {
  value: String
}

"""
aggregate max on columns
"""
type transcription_status_max_fields {
  value: String
}

"""
order by max() on columns of table "transcription_status"
"""
input transcription_status_max_order_by {
  value: order_by
}

"""
aggregate min on columns
"""
type transcription_status_min_fields {
  value: String
}

"""
order by min() on columns of table "transcription_status"
"""
input transcription_status_min_order_by {
  value: order_by
}

"""
response of any mutation on the table "transcription_status"
"""
type transcription_status_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [transcription_status!]!
}

"""
input type for inserting object relation for remote table "transcription_status"
"""
input transcription_status_obj_rel_insert_input {
  data: transcription_status_insert_input!
  on_conflict: transcription_status_on_conflict
}

"""
on conflict condition type for table "transcription_status"
"""
input transcription_status_on_conflict {
  constraint: transcription_status_constraint!
  update_columns: [transcription_status_update_column!]!
  where: transcription_status_bool_exp
}

"""
ordering options when selecting data from "transcription_status"
"""
input transcription_status_order_by {
  value: order_by
}

"""
primary key columns input for table: "transcription_status"
"""
input transcription_status_pk_columns_input {
  value: String!
}

"""
select columns of table "transcription_status"
"""
enum transcription_status_select_column {
  """
  column name
  """
  value
}

"""
input type for updating data in table "transcription_status"
"""
input transcription_status_set_input {
  value: String
}

"""
update columns of table "transcription_status"
"""
enum transcription_status_update_column {
  """
  column name
  """
  value
}

"""
update columns of table "transcription"
"""
enum transcription_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  sonix_media_id

  """
  column name
  """
  status

  """
  column name
  """
  transcript

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "unread_messages"
"""
type unread_messages {
  room_id: uuid
  topic_id: uuid
  unread_messages: bigint
  user_id: uuid
}

"""
aggregated selection of "unread_messages"
"""
type unread_messages_aggregate {
  aggregate: unread_messages_aggregate_fields
  nodes: [unread_messages!]!
}

"""
aggregate fields of "unread_messages"
"""
type unread_messages_aggregate_fields {
  avg: unread_messages_avg_fields
  count(columns: [unread_messages_select_column!], distinct: Boolean): Int
  max: unread_messages_max_fields
  min: unread_messages_min_fields
  stddev: unread_messages_stddev_fields
  stddev_pop: unread_messages_stddev_pop_fields
  stddev_samp: unread_messages_stddev_samp_fields
  sum: unread_messages_sum_fields
  var_pop: unread_messages_var_pop_fields
  var_samp: unread_messages_var_samp_fields
  variance: unread_messages_variance_fields
}

"""
order by aggregate values of table "unread_messages"
"""
input unread_messages_aggregate_order_by {
  avg: unread_messages_avg_order_by
  count: order_by
  max: unread_messages_max_order_by
  min: unread_messages_min_order_by
  stddev: unread_messages_stddev_order_by
  stddev_pop: unread_messages_stddev_pop_order_by
  stddev_samp: unread_messages_stddev_samp_order_by
  sum: unread_messages_sum_order_by
  var_pop: unread_messages_var_pop_order_by
  var_samp: unread_messages_var_samp_order_by
  variance: unread_messages_variance_order_by
}

"""
aggregate avg on columns
"""
type unread_messages_avg_fields {
  unread_messages: Float
}

"""
order by avg() on columns of table "unread_messages"
"""
input unread_messages_avg_order_by {
  unread_messages: order_by
}

"""
Boolean expression to filter rows from the table "unread_messages". All fields are combined with a logical 'AND'.
"""
input unread_messages_bool_exp {
  _and: [unread_messages_bool_exp]
  _not: unread_messages_bool_exp
  _or: [unread_messages_bool_exp]
  room_id: uuid_comparison_exp
  topic_id: uuid_comparison_exp
  unread_messages: bigint_comparison_exp
  user_id: uuid_comparison_exp
}

"""
aggregate max on columns
"""
type unread_messages_max_fields {
  room_id: uuid
  topic_id: uuid
  unread_messages: bigint
  user_id: uuid
}

"""
order by max() on columns of table "unread_messages"
"""
input unread_messages_max_order_by {
  room_id: order_by
  topic_id: order_by
  unread_messages: order_by
  user_id: order_by
}

"""
aggregate min on columns
"""
type unread_messages_min_fields {
  room_id: uuid
  topic_id: uuid
  unread_messages: bigint
  user_id: uuid
}

"""
order by min() on columns of table "unread_messages"
"""
input unread_messages_min_order_by {
  room_id: order_by
  topic_id: order_by
  unread_messages: order_by
  user_id: order_by
}

"""
ordering options when selecting data from "unread_messages"
"""
input unread_messages_order_by {
  room_id: order_by
  topic_id: order_by
  unread_messages: order_by
  user_id: order_by
}

"""
select columns of table "unread_messages"
"""
enum unread_messages_select_column {
  """
  column name
  """
  room_id

  """
  column name
  """
  topic_id

  """
  column name
  """
  unread_messages

  """
  column name
  """
  user_id
}

"""
aggregate stddev on columns
"""
type unread_messages_stddev_fields {
  unread_messages: Float
}

"""
order by stddev() on columns of table "unread_messages"
"""
input unread_messages_stddev_order_by {
  unread_messages: order_by
}

"""
aggregate stddev_pop on columns
"""
type unread_messages_stddev_pop_fields {
  unread_messages: Float
}

"""
order by stddev_pop() on columns of table "unread_messages"
"""
input unread_messages_stddev_pop_order_by {
  unread_messages: order_by
}

"""
aggregate stddev_samp on columns
"""
type unread_messages_stddev_samp_fields {
  unread_messages: Float
}

"""
order by stddev_samp() on columns of table "unread_messages"
"""
input unread_messages_stddev_samp_order_by {
  unread_messages: order_by
}

"""
aggregate sum on columns
"""
type unread_messages_sum_fields {
  unread_messages: bigint
}

"""
order by sum() on columns of table "unread_messages"
"""
input unread_messages_sum_order_by {
  unread_messages: order_by
}

"""
aggregate var_pop on columns
"""
type unread_messages_var_pop_fields {
  unread_messages: Float
}

"""
order by var_pop() on columns of table "unread_messages"
"""
input unread_messages_var_pop_order_by {
  unread_messages: order_by
}

"""
aggregate var_samp on columns
"""
type unread_messages_var_samp_fields {
  unread_messages: Float
}

"""
order by var_samp() on columns of table "unread_messages"
"""
input unread_messages_var_samp_order_by {
  unread_messages: order_by
}

"""
aggregate variance on columns
"""
type unread_messages_variance_fields {
  unread_messages: Float
}

"""
order by variance() on columns of table "unread_messages"
"""
input unread_messages_variance_order_by {
  unread_messages: order_by
}

"""
columns and relationships of "user"
"""
type user {
  avatar_url: String
  created_at: timestamptz!

  """
  An array relationship
  """
  created_room_invitations(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): [room_invitation!]!

  """
  An aggregated array relationship
  """
  created_room_invitations_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_invitation_order_by!]

    """
    filter the rows returned
    """
    where: room_invitation_bool_exp
  ): room_invitation_aggregate!

  """
  An array relationship
  """
  created_rooms(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): [room!]!

  """
  An aggregated array relationship
  """
  created_rooms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_order_by!]

    """
    filter the rows returned
    """
    where: room_bool_exp
  ): room_aggregate!

  """
  An array relationship
  """
  created_team_invitations(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): [team_invitation!]!

  """
  An aggregated array relationship
  """
  created_team_invitations_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_invitation_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_invitation_order_by!]

    """
    filter the rows returned
    """
    where: team_invitation_bool_exp
  ): team_invitation_aggregate!

  """
  An object relationship
  """
  current_team: team
  current_team_id: uuid
  email: String
  email_verified: timestamptz
  id: uuid!

  """
  An array relationship
  """
  messages(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): [message!]!

  """
  An aggregated array relationship
  """
  messages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [message_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [message_order_by!]

    """
    filter the rows returned
    """
    where: message_bool_exp
  ): message_aggregate!
  name: String

  """
  An array relationship
  """
  notifications(
    """
    distinct select on columns
    """
    distinct_on: [notification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [notification_order_by!]

    """
    filter the rows returned
    """
    where: notification_bool_exp
  ): [notification!]!

  """
  An aggregated array relationship
  """
  notifications_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [notification_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [notification_order_by!]

    """
    filter the rows returned
    """
    where: notification_bool_exp
  ): notification_aggregate!

  """
  An array relationship
  """
  owned_teams(
    """
    distinct select on columns
    """
    distinct_on: [team_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_order_by!]

    """
    filter the rows returned
    """
    where: team_bool_exp
  ): [team!]!

  """
  An aggregated array relationship
  """
  owned_teams_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_order_by!]

    """
    filter the rows returned
    """
    where: team_bool_exp
  ): team_aggregate!

  """
  An array relationship
  """
  rooms(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): [room_member!]!

  """
  An aggregated array relationship
  """
  rooms_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [room_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [room_member_order_by!]

    """
    filter the rows returned
    """
    where: room_member_bool_exp
  ): room_member_aggregate!

  """
  An array relationship
  """
  space_memberships(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): [space_member!]!

  """
  An aggregated array relationship
  """
  space_memberships_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [space_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [space_member_order_by!]

    """
    filter the rows returned
    """
    where: space_member_bool_exp
  ): space_member_aggregate!

  """
  An array relationship
  """
  team_memberships(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): [team_member!]!

  """
  An aggregated array relationship
  """
  team_memberships_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [team_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [team_member_order_by!]

    """
    filter the rows returned
    """
    where: team_member_bool_exp
  ): team_member_aggregate!

  """
  An array relationship
  """
  topic_memberships(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): [topic_member!]!

  """
  An aggregated array relationship
  """
  topic_memberships_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_member_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_member_order_by!]

    """
    filter the rows returned
    """
    where: topic_member_bool_exp
  ): topic_member_aggregate!
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  avatar_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_room_invitations: room_invitation_bool_exp
  created_rooms: room_bool_exp
  created_team_invitations: team_invitation_bool_exp
  current_team: team_bool_exp
  current_team_id: uuid_comparison_exp
  email: String_comparison_exp
  email_verified: timestamptz_comparison_exp
  id: uuid_comparison_exp
  messages: message_bool_exp
  name: String_comparison_exp
  notifications: notification_bool_exp
  owned_teams: team_bool_exp
  rooms: room_member_bool_exp
  space_memberships: space_member_bool_exp
  team_memberships: team_member_bool_exp
  topic_memberships: topic_member_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint
  """
  user_email_key

  """
  unique or primary key constraint
  """
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  avatar_url: String
  created_at: timestamptz
  created_room_invitations: room_invitation_arr_rel_insert_input
  created_rooms: room_arr_rel_insert_input
  created_team_invitations: team_invitation_arr_rel_insert_input
  current_team: team_obj_rel_insert_input
  current_team_id: uuid
  email: String
  email_verified: timestamptz
  id: uuid
  messages: message_arr_rel_insert_input
  name: String
  notifications: notification_arr_rel_insert_input
  owned_teams: team_arr_rel_insert_input
  rooms: room_member_arr_rel_insert_input
  space_memberships: space_member_arr_rel_insert_input
  team_memberships: team_member_arr_rel_insert_input
  topic_memberships: topic_member_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type user_max_fields {
  avatar_url: String
  created_at: timestamptz
  current_team_id: uuid
  email: String
  email_verified: timestamptz
  id: uuid
  name: String
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  avatar_url: order_by
  created_at: order_by
  current_team_id: order_by
  email: order_by
  email_verified: order_by
  id: order_by
  name: order_by
}

"""
aggregate min on columns
"""
type user_min_fields {
  avatar_url: String
  created_at: timestamptz
  current_team_id: uuid
  email: String
  email_verified: timestamptz
  id: uuid
  name: String
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  avatar_url: order_by
  created_at: order_by
  current_team_id: order_by
  email: order_by
  email_verified: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
ordering options when selecting data from "user"
"""
input user_order_by {
  avatar_url: order_by
  created_at: order_by
  created_room_invitations_aggregate: room_invitation_aggregate_order_by
  created_rooms_aggregate: room_aggregate_order_by
  created_team_invitations_aggregate: team_invitation_aggregate_order_by
  current_team: team_order_by
  current_team_id: order_by
  email: order_by
  email_verified: order_by
  id: order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  notifications_aggregate: notification_aggregate_order_by
  owned_teams_aggregate: team_aggregate_order_by
  rooms_aggregate: room_member_aggregate_order_by
  space_memberships_aggregate: space_member_aggregate_order_by
  team_memberships_aggregate: team_member_aggregate_order_by
  topic_memberships_aggregate: topic_member_aggregate_order_by
}

"""
primary key columns input for table: "user"
"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """
  column name
  """
  avatar_url

  """
  column name
  """
  created_at

  """
  column name
  """
  current_team_id

  """
  column name
  """
  email

  """
  column name
  """
  email_verified

  """
  column name
  """
  id

  """
  column name
  """
  name
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  avatar_url: String
  created_at: timestamptz
  current_team_id: uuid
  email: String
  email_verified: timestamptz
  id: uuid
  name: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """
  column name
  """
  avatar_url

  """
  column name
  """
  created_at

  """
  column name
  """
  current_team_id

  """
  column name
  """
  email

  """
  column name
  """
  email_verified

  """
  column name
  """
  id

  """
  column name
  """
  name
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "whitelist"
"""
type whitelist {
  email: String!
  is_approved: Boolean!
  timestamp: timestamptz!
}

"""
aggregated selection of "whitelist"
"""
type whitelist_aggregate {
  aggregate: whitelist_aggregate_fields
  nodes: [whitelist!]!
}

"""
aggregate fields of "whitelist"
"""
type whitelist_aggregate_fields {
  count(columns: [whitelist_select_column!], distinct: Boolean): Int
  max: whitelist_max_fields
  min: whitelist_min_fields
}

"""
order by aggregate values of table "whitelist"
"""
input whitelist_aggregate_order_by {
  count: order_by
  max: whitelist_max_order_by
  min: whitelist_min_order_by
}

"""
input type for inserting array relation for remote table "whitelist"
"""
input whitelist_arr_rel_insert_input {
  data: [whitelist_insert_input!]!
  on_conflict: whitelist_on_conflict
}

"""
Boolean expression to filter rows from the table "whitelist". All fields are combined with a logical 'AND'.
"""
input whitelist_bool_exp {
  _and: [whitelist_bool_exp]
  _not: whitelist_bool_exp
  _or: [whitelist_bool_exp]
  email: String_comparison_exp
  is_approved: Boolean_comparison_exp
  timestamp: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "whitelist"
"""
enum whitelist_constraint {
  """
  unique or primary key constraint
  """
  whitelist_pkey
}

"""
input type for inserting data into table "whitelist"
"""
input whitelist_insert_input {
  email: String
  is_approved: Boolean
  timestamp: timestamptz
}

"""
aggregate max on columns
"""
type whitelist_max_fields {
  email: String
  timestamp: timestamptz
}

"""
order by max() on columns of table "whitelist"
"""
input whitelist_max_order_by {
  email: order_by
  timestamp: order_by
}

"""
aggregate min on columns
"""
type whitelist_min_fields {
  email: String
  timestamp: timestamptz
}

"""
order by min() on columns of table "whitelist"
"""
input whitelist_min_order_by {
  email: order_by
  timestamp: order_by
}

"""
response of any mutation on the table "whitelist"
"""
type whitelist_mutation_response {
  """
  number of affected rows by the mutation
  """
  affected_rows: Int!

  """
  data of the affected rows by the mutation
  """
  returning: [whitelist!]!
}

"""
input type for inserting object relation for remote table "whitelist"
"""
input whitelist_obj_rel_insert_input {
  data: whitelist_insert_input!
  on_conflict: whitelist_on_conflict
}

"""
on conflict condition type for table "whitelist"
"""
input whitelist_on_conflict {
  constraint: whitelist_constraint!
  update_columns: [whitelist_update_column!]!
  where: whitelist_bool_exp
}

"""
ordering options when selecting data from "whitelist"
"""
input whitelist_order_by {
  email: order_by
  is_approved: order_by
  timestamp: order_by
}

"""
primary key columns input for table: "whitelist"
"""
input whitelist_pk_columns_input {
  email: String!
}

"""
select columns of table "whitelist"
"""
enum whitelist_select_column {
  """
  column name
  """
  email

  """
  column name
  """
  is_approved

  """
  column name
  """
  timestamp
}

"""
input type for updating data in table "whitelist"
"""
input whitelist_set_input {
  email: String
  is_approved: Boolean
  timestamp: timestamptz
}

"""
update columns of table "whitelist"
"""
enum whitelist_update_column {
  """
  column name
  """
  email

  """
  column name
  """
  is_approved

  """
  column name
  """
  timestamp
}
